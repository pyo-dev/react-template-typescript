import React, { useEffect, useRef, useState } from "react";

type DataPoint = [number, number, number, ...number[]];

interface Props {
  data: DataPoint[];
  fontColor?: string;
  fontColorSelected?: string;
  onSelectionChange?: (selected: DataPoint[]) => void;
}

export default function WaferHeatmap({
  data,
  fontColor = "#000",
  fontColorSelected = "#fff",
  onSelectionChange,
}: Props) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const wrapperRef = useRef<HTMLDivElement>(null);

  /* ================= META ================= */
  const metaRef = useRef({
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0,
    w: 0,
    h: 0,
  });

  /* ================= STATE REFS ================= */
  const selectedCellsRef = useRef<Set<string>>(new Set());

  const dragRef = useRef({
    startX: 0,
    startY: 0,
    endX: 0,
    endY: 0,
    dragging: false,
  });

  const dragHappenedRef = useRef(false);
  const panHappenedRef = useRef(false);
  const suppressClickRef = useRef(false);

  const scaleRef = useRef(1);
  const offsetRef = useRef({ x: 0, y: 0 });

  const [tooltip, setTooltip] = useState<{
    px: number;
    py: number;
    data: DataPoint;
  } | null>(null);

  /* ================= META 계산 ================= */
  useEffect(() => {
    if (!data.length) return;
    const xs = data.map(d => d[0]);
    const ys = data.map(d => d[1]);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);

    metaRef.current = {
      minX,
      maxX,
      minY,
      maxY,
      w: maxX - minX + 1,
      h: maxY - minY + 1,
    };
  }, [data]);

  /* ================= Resize ================= */
  useEffect(() => {
    const wrapper = wrapperRef.current;
    if (!wrapper) return;

    const ro = new ResizeObserver(() => {
      const canvas = canvasRef.current!;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = wrapper.clientWidth * dpr;
      canvas.height = wrapper.clientHeight * dpr;
      canvas.style.width = `${wrapper.clientWidth}px`;
      canvas.style.height = `${wrapper.clientHeight}px`;
      draw();
    });

    ro.observe(wrapper);
    return () => ro.disconnect();
  }, []);

  /* ================= UTIL ================= */
  const getCellSize = () => {
    const canvas = canvasRef.current!;
    const { w, h } = metaRef.current;
    return Math.min(canvas.clientWidth, canvas.clientHeight) / Math.max(w, h);
  };

  // ✅ 실제 그려지는 영역 기준 중앙 정렬
  const getBaseOffset = () => {
    const canvas = canvasRef.current!;
    const cell = getCellSize();
    const { minX, maxX, minY, maxY } = metaRef.current;

    const drawWidth = (maxX - minX + 1) * cell;
    const drawHeight = (maxY - minY + 1) * cell;

    return {
      x: (canvas.clientWidth - drawWidth) / 2,
      y: (canvas.clientHeight - drawHeight) / 2,
    };
  };

  /* ================= DRAW ================= */
  const draw = () => {
    const canvas = canvasRef.current!;
    const ctx = canvas.getContext("2d")!;
    const dpr = window.devicePixelRatio || 1;

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.scale(dpr, dpr);
    ctx.save();
    ctx.translate(offsetRef.current.x, offsetRef.current.y);
    ctx.scale(scaleRef.current, scaleRef.current);

    const cell = getCellSize();
    const base = getBaseOffset();
    const { minX, minY } = metaRef.current;

    /* 셀 렌더 */
    for (const d of data) {
      const [x, y, v] = d;
      const gx = x - minX;
      const gy = y - minY;
      const key = `${x},${y}`;

      ctx.fillStyle = selectedCellsRef.current.has(key)
        ? "rgba(255,0,0,0.7)"
        : `hsl(${240 - v * 2},80%,50%)`;

      ctx.fillRect(
        base.x + gx * cell,
        base.y + gy * cell,
        cell,
        cell
      );

      ctx.fillStyle = selectedCellsRef.current.has(key)
        ? fontColorSelected
        : fontColor;

      ctx.font = `${cell * 0.45}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(
        String(v),
        base.x + gx * cell + cell / 2,
        base.y + gy * cell + cell / 2
      );
    }

    /* 그리드 */
    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (const d of data) {
      const gx = d[0] - minX;
      const gy = d[1] - minY;
      ctx.rect(
        base.x + gx * cell + 0.5,
        base.y + gy * cell + 0.5,
        cell,
        cell
      );
    }
    ctx.stroke();

    /* 드래그 오버레이 */
    if (dragRef.current.dragging && !panHappenedRef.current) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      const x = Math.min(dragRef.current.startX, dragRef.current.endX);
      const y = Math.min(dragRef.current.startY, dragRef.current.endY);
      const w = Math.abs(dragRef.current.endX - dragRef.current.startX);
      const h = Math.abs(dragRef.current.endY - dragRef.current.startY);

      ctx.fillStyle = "rgba(0,120,255,0.25)";
      ctx.strokeStyle = "rgba(0,120,255,0.9)";
      ctx.fillRect(x, y, w, h);
      ctx.strokeRect(x, y, w, h);
    }

    ctx.restore();
  };

  /* ================= EVENTS ================= */
  const handleDown = (e: React.MouseEvent) => {
    dragHappenedRef.current = false;
    panHappenedRef.current = false;
    suppressClickRef.current = false;

    const rect = canvasRef.current!.getBoundingClientRect();
    dragRef.current = {
      startX: e.clientX - rect.left,
      startY: e.clientY - rect.top,
      endX: e.clientX - rect.left,
      endY: e.clientY - rect.top,
      dragging: true,
    };
  };

  const handleMove = (e: React.MouseEvent) => {
    const canvas = canvasRef.current!;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    /* tooltip */
    const cell = getCellSize();
    const base = getBaseOffset();
    const { minX, minY } = metaRef.current;

    const lx = (mx - offsetRef.current.x) / scaleRef.current - base.x;
    const ly = (my - offsetRef.current.y) / scaleRef.current - base.y;
    const gx = Math.floor(lx / cell);
    const gy = Math.floor(ly / cell);

    const hit = data.find(
      d => d[0] === minX + gx && d[1] === minY + gy
    );
    setTooltip(hit ? { px: mx, py: my, data: hit } : null);

    if (!dragRef.current.dragging) return;

    dragHappenedRef.current = true;

    /* 패닝 */
    if (e.shiftKey && scaleRef.current !== 1) {
      panHappenedRef.current = true;
      offsetRef.current.x += mx - dragRef.current.startX;
      offsetRef.current.y += my - dragRef.current.startY;
      dragRef.current.startX = mx;
      dragRef.current.startY = my;
      draw();
      return;
    }

    /* 드래그 선택 */
    dragRef.current.endX = mx;
    dragRef.current.endY = my;

    const x0 = Math.min(dragRef.current.startX, dragRef.current.endX);
    const x1 = Math.max(dragRef.current.startX, dragRef.current.endX);
    const y0 = Math.min(dragRef.current.startY, dragRef.current.endY);
    const y1 = Math.max(dragRef.current.startY, dragRef.current.endY);

    for (const d of data) {
      const cx =
        offsetRef.current.x +
        scaleRef.current * (base.x + (d[0] - minX) * cell);
      const cy =
        offsetRef.current.y +
        scaleRef.current * (base.y + (d[1] - minY) * cell);

      if (
        cx + cell * scaleRef.current >= x0 &&
        cx <= x1 &&
        cy + cell * scaleRef.current >= y0 &&
        cy <= y1
      ) {
        selectedCellsRef.current.add(`${d[0]},${d[1]}`);
      }
    }

    draw();
  };

  const handleUp = () => {
    dragRef.current.dragging = false;

    if (dragHappenedRef.current && !panHappenedRef.current) {
      onSelectionChange?.(
        data.filter(d =>
          selectedCellsRef.current.has(`${d[0]},${d[1]}`)
        )
      );
    }

    suppressClickRef.current =
      dragHappenedRef.current || panHappenedRef.current;

    draw();

    setTimeout(() => {
      dragHappenedRef.current = false;
      panHappenedRef.current = false;
      suppressClickRef.current = false;
    }, 0);
  };

  const handleClick = (e: React.MouseEvent) => {
    if (suppressClickRef.current) return;

    const canvas = canvasRef.current!;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const cell = getCellSize();
    const base = getBaseOffset();
    const { minX, minY } = metaRef.current;

    const lx = (mx - offsetRef.current.x) / scaleRef.current - base.x;
    const ly = (my - offsetRef.current.y) / scaleRef.current - base.y;
    const gx = Math.floor(lx / cell);
    const gy = Math.floor(ly / cell);

    const key = `${minX + gx},${minY + gy}`;
    if (selectedCellsRef.current.has(key))
      selectedCellsRef.current.delete(key);
    else selectedCellsRef.current.add(key);

    draw();

    onSelectionChange?.(
      data.filter(d =>
        selectedCellsRef.current.has(`${d[0]},${d[1]}`)
      )
    );
  };

  /* ======= 마우스 기준 확대/축소 ======= */
  const handleWheel = (e: React.WheelEvent) => {
    if (!e.shiftKey) return;
    e.preventDefault();

    const canvas = canvasRef.current!;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const oldScale = scaleRef.current;
    const factor = 1.05;
    const nextScale =
      oldScale * (e.deltaY < 0 ? factor : 1 / factor);

    const newScale = Math.max(1, Math.min(nextScale, 10));

    const worldX = (mx - offsetRef.current.x) / oldScale;
    const worldY = (my - offsetRef.current.y) / oldScale;

    scaleRef.current = newScale;
    offsetRef.current.x = mx - worldX * newScale;
    offsetRef.current.y = my - worldY * newScale;

    if (newScale === 1) {
      offsetRef.current = { x: 0, y: 0 };
    }

    draw();
  };

  const handleReset = () => {
    scaleRef.current = 1;
    offsetRef.current = { x: 0, y: 0 };
    selectedCellsRef.current.clear();
    onSelectionChange?.([]);
    draw();
  };

  return (
    <div
      ref={wrapperRef}
      style={{ width: "100%", height: "100%", position: "relative" }}
      onWheel={handleWheel}
    >
      <button
        onClick={handleReset}
        style={{ position: "absolute", right: 10, top: 10, zIndex: 10 }}
      >
        Reset
      </button>

      <canvas
        ref={canvasRef}
        onMouseDown={handleDown}
        onMouseMove={handleMove}
        onMouseUp={handleUp}
        onClick={handleClick}
        onMouseLeave={() => {
          dragRef.current.dragging = false;
          setTooltip(null);
          draw();
        }}
      />

      {tooltip && (
        <div
          style={{
            position: "absolute",
            left: tooltip.px + 10,
            top: tooltip.py + 10,
            background: "#111",
            color: "#fff",
            fontSize: 12,
            padding: "4px 6px",
            borderRadius: 4,
            pointerEvents: "none",
            whiteSpace: "nowrap",
          }}
        >
          {tooltip.data.map((v, i) => (
            <div key={i}>{v}</div>
          ))}
        </div>
      )}
    </div>
  );
}
