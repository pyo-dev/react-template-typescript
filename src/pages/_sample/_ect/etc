import React, { useEffect, useRef, useState } from "react";

type DataPoint = [number, number, number, ...number[]];

interface Props {
  data: DataPoint[];
  fontColor?: string;
  fontColorSelected?: string;
  onSelectionChange?: (selected: DataPoint[]) => void;
}

export default function WaferHeatmap({
  data,
  fontColor = "#000",
  fontColorSelected = "#fff",
  onSelectionChange,
}: Props) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const wrapperRef = useRef<HTMLDivElement>(null);

  const metaRef = useRef({ minX: 0, maxX: 0, minY: 0, maxY: 0, w: 0, h: 0 });
  const selectedCellsRef = useRef<Set<string>>(new Set());

  const dragRef = useRef({
    dragging: false,
    startWX: 0,
    startWY: 0,
    currWX: 0,
    currWY: 0,
  });

  const dragHappenedRef = useRef(false);
  const scaleRef = useRef(1);
  const offsetRef = useRef({ x: 0, y: 0 });
  const panRef = useRef(false);

  const [tooltip, setTooltip] = useState<{
    x: number;
    y: number;
    v: number;
    px: number;
    py: number;
    extra: number[];
  } | null>(null);

  /* =========================
     META
  ========================= */
  useEffect(() => {
    if (!data.length) return;
    const xs = data.map(d => d[0]);
    const ys = data.map(d => d[1]);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    metaRef.current = {
      minX,
      maxX,
      minY,
      maxY,
      w: maxX - minX + 1,
      h: maxY - minY + 1,
    };
  }, [data]);

  /* =========================
     RESIZE
  ========================= */
  useEffect(() => {
    const wrapper = wrapperRef.current;
    if (!wrapper) return;

    const ro = new ResizeObserver(() => {
      const canvas = canvasRef.current!;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = wrapper.clientWidth * dpr;
      canvas.height = wrapper.clientHeight * dpr;
      canvas.style.width = `${wrapper.clientWidth}px`;
      canvas.style.height = `${wrapper.clientHeight}px`;
      draw();
    });

    ro.observe(wrapper);
    return () => ro.disconnect();
  }, [data]);

  const getCellSize = () => {
    const canvas = canvasRef.current!;
    const { w, h } = metaRef.current;
    const size = Math.min(canvas.clientWidth, canvas.clientHeight);
    return Math.max(1, Math.floor(size / Math.max(w, h)));
  };

  /* =========================
     DRAW
  ========================= */
  const draw = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d")!;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.setTransform(
      scaleRef.current,
      0,
      0,
      scaleRef.current,
      offsetRef.current.x,
      offsetRef.current.y
    );

    const { minX, maxY, w, h } = metaRef.current;
    const cell = getCellSize();
    const cw = wrapperRef.current!.clientWidth;
    const ch = wrapperRef.current!.clientHeight;

    const ox = (cw / scaleRef.current - w * cell) / 2;
    const oy = (ch / scaleRef.current - h * cell) / 2;

    // cells
    for (const d of data) {
      const [x, y, v] = d;
      const gx = x - minX;
      const gy = maxY - y;
      const key = `${x},${y}`;

      ctx.fillStyle = selectedCellsRef.current.has(key)
        ? "rgba(255,0,0,0.7)"
        : `hsl(${240 - v * 2},80%,50%)`;

      ctx.fillRect(ox + gx * cell, oy + gy * cell, cell, cell);

      ctx.fillStyle = selectedCellsRef.current.has(key)
        ? fontColorSelected
        : fontColor;

      ctx.font = `${Math.floor(cell * 0.5)}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(
        v.toString(),
        ox + gx * cell + cell / 2,
        oy + gy * cell + cell / 2
      );
    }

    // grid
    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (const [x, y] of data) {
      const gx = x - minX;
      const gy = maxY - y;
      const px = ox + gx * cell;
      const py = oy + gy * cell;
      ctx.rect(px, py, cell, cell);
    }
    ctx.stroke();

    // drag overlay
    if (dragRef.current.dragging && !panRef.current) {
      const x0 = Math.min(dragRef.current.startWX, dragRef.current.currWX);
      const x1 = Math.max(dragRef.current.startWX, dragRef.current.currWX);
      const y0 = Math.min(dragRef.current.startWY, dragRef.current.currWY);
      const y1 = Math.max(dragRef.current.startWY, dragRef.current.currWY);

      ctx.fillStyle = "rgba(0,120,255,0.25)";
      ctx.strokeStyle = "rgba(0,120,255,0.9)";
      ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
      ctx.strokeRect(x0, y0, x1 - x0, y1 - y0);
    }

    ctx.restore();
  };

  /* =========================
     MOUSE
  ========================= */
  const getWorldPos = (e: React.MouseEvent) => {
    const rect = canvasRef.current!.getBoundingClientRect();
    return {
      wx: (e.clientX - rect.left - offsetRef.current.x) / scaleRef.current,
      wy: (e.clientY - rect.top - offsetRef.current.y) / scaleRef.current,
      px: e.clientX - rect.left,
      py: e.clientY - rect.top,
    };
  };

  const handleDown = (e: React.MouseEvent) => {
    dragHappenedRef.current = false;
    panRef.current = e.shiftKey && scaleRef.current !== 1;

    const { wx, wy } = getWorldPos(e);
    dragRef.current = {
      dragging: true,
      startWX: wx,
      startWY: wy,
      currWX: wx,
      currWY: wy,
    };
  };

  const handleMove = (e: React.MouseEvent) => {
    const { wx, wy, px, py } = getWorldPos(e);

    // tooltip
    const { minX, maxY, w, h } = metaRef.current;
    const cell = getCellSize();
    const cw = wrapperRef.current!.clientWidth;
    const ch = wrapperRef.current!.clientHeight;
    const ox = (cw / scaleRef.current - w * cell) / 2;
    const oy = (ch / scaleRef.current - h * cell) / 2;

    const gx = Math.floor((wx - ox) / cell);
    const gy = Math.floor((wy - oy) / cell);
    const dx = minX + gx;
    const dy = maxY - gy;
    const found = data.find(d => d[0] === dx && d[1] === dy);

    setTooltip(
      found
        ? {
            x: dx,
            y: dy,
            v: found[2],
            extra: found.slice(3),
            px,
            py,
          }
        : null
    );

    if (!dragRef.current.dragging) return;

    dragHappenedRef.current = true;

    if (panRef.current) {
      offsetRef.current.x += e.movementX;
      offsetRef.current.y += e.movementY;
      draw();
      return;
    }

    dragRef.current.currWX = wx;
    dragRef.current.currWY = wy;

    const x0 = Math.min(dragRef.current.startWX, wx);
    const x1 = Math.max(dragRef.current.startWX, wx);
    const y0 = Math.min(dragRef.current.startWY, wy);
    const y1 = Math.max(dragRef.current.startWY, wy);

    for (const [x, y] of data) {
      const cx = ox + (x - minX) * cell;
      const cy = oy + (maxY - y) * cell;

      if (cx + cell >= x0 && cx <= x1 && cy + cell >= y0 && cy <= y1) {
        selectedCellsRef.current.add(`${x},${y}`);
      }
    }

    draw();
  };

  const handleUp = () => {
    dragRef.current.dragging = false;
    panRef.current = false;
    draw();

    if (dragHappenedRef.current && onSelectionChange) {
      const selected = data.filter(d =>
        selectedCellsRef.current.has(`${d[0]},${d[1]}`)
      );
      onSelectionChange(selected);
    }

    dragHappenedRef.current = false;
  };

  const handleClick = (e: React.MouseEvent) => {
    if (dragHappenedRef.current || panRef.current) return;

    const { wx, wy } = getWorldPos(e);
    const { minX, maxY, w, h } = metaRef.current;
    const cell = getCellSize();
    const cw = wrapperRef.current!.clientWidth;
    const ch = wrapperRef.current!.clientHeight;
    const ox = (cw / scaleRef.current - w * cell) / 2;
    const oy = (ch / scaleRef.current - h * cell) / 2;

    const gx = Math.floor((wx - ox) / cell);
    const gy = Math.floor((wy - oy) / cell);
    const x = minX + gx;
    const y = maxY - gy;

    const key = `${x},${y}`;
    if (!data.find(d => d[0] === x && d[1] === y)) return;

    selectedCellsRef.current.has(key)
      ? selectedCellsRef.current.delete(key)
      : selectedCellsRef.current.add(key);

    draw();

    if (onSelectionChange) {
      const selected = data.filter(d =>
        selectedCellsRef.current.has(`${d[0]},${d[1]}`)
      );
      onSelectionChange(selected);
    }
  };

  const handleWheel = (e: React.WheelEvent) => {
    if (!e.shiftKey) return;
    e.preventDefault();

    const factor = e.deltaY < 0 ? 1.05 : 1 / 1.05;
    scaleRef.current = Math.min(10, Math.max(1, scaleRef.current * factor));
    draw();
  };

  return (
    <div
      ref={wrapperRef}
      style={{ width: "100%", height: "100%", position: "relative" }}
      onWheel={handleWheel}
    >
      <canvas
        ref={canvasRef}
        onMouseDown={handleDown}
        onMouseMove={handleMove}
        onMouseUp={handleUp}
        onClick={handleClick}
        onMouseLeave={() => {
          dragRef.current.dragging = false;
          panRef.current = false;
          setTooltip(null);
          draw();
        }}
      />
      {tooltip && (
        <div
          style={{
            position: "absolute",
            left: tooltip.px + 10,
            top: tooltip.py + 10,
            background: "#111",
            color: "#fff",
            fontSize: 12,
            padding: "4px 6px",
            borderRadius: 4,
            pointerEvents: "none",
            whiteSpace: "nowrap",
          }}
        >
          x:{tooltip.x} y:{tooltip.y} v:{tooltip.v}
          {tooltip.extra.map((v, i) => (
            <span key={i}> , {v}</span>
          ))}
        </div>
      )}
    </div>
  );
}
