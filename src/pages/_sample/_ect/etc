import { useEffect, useRef, useState } from "react";
import Plot from "react-plotly.js";
import Plotly from "plotly.js-dist-min";
import type { Layout, Config } from "plotly.js";

type PlotlyGraphDiv = HTMLDivElement & {
  layout: {
    xaxis: { range?: [number, number] };
    yaxis: { range?: [number, number] };
  };
};

type CellKey = `${number}-${number}`;

const WaferHeatmap: React.FC = () => {
  const wrapperRef = useRef<HTMLDivElement | null>(null);
  const plotRef = useRef<PlotlyGraphDiv | null>(null);

  /* ================= ë°ì´í„° ================= */
  const R = 100;

  const x = Array.from({ length: 200 }, (_, i) => i - 100);
  const y = Array.from({ length: 200 }, (_, i) => i - 100);

  const originalZ = useRef<number[][]>(
    y.map((yy) =>
      x.map((xx) =>
        xx * xx + yy * yy <= R * R ? Math.random() * 10 : NaN
      )
    )
  );

  const [z, setZ] = useState<number[][]>(
    originalZ.current.map((r) => [...r])
  );

  /* ================= ì„ íƒ ìƒíƒœ ================= */
  const selectedRef = useRef<Set<CellKey>>(new Set());

  /* ================= ë“œë˜ê·¸ ìƒíƒœ ================= */
  const isSelectingRef = useRef(false);
  const startRef = useRef({ x: 0, y: 0 });

  /* ================= layout ================= */
  const layout: Partial<Layout> = {
    dragmode: false,
    margin: { t: 20, r: 20, b: 20, l: 20 },
    xaxis: {
      range: [-100, 100],
      scaleanchor: "y",
      scaleratio: 1,
    },
    yaxis: {
      range: [-100, 100],
      scaleanchor: "x",
      scaleratio: 1,
    },
  };

  const config: Partial<Config> = {
    scrollZoom: false,
    doubleClick: false,
  };

  /* ================= ì¢Œí‘œ ë³€í™˜ ================= */
  const pixelToData = (e: MouseEvent, plot: PlotlyGraphDiv) => {
    const rect = plot.getBoundingClientRect();
    const [x0, x1] = plot.layout.xaxis.range!;
    const [y0, y1] = plot.layout.yaxis.range!;

    return {
      x: x0 + ((e.clientX - rect.left) / rect.width) * (x1 - x0),
      y: y1 - ((e.clientY - rect.top) / rect.height) * (y1 - y0),
    };
  };

  /* ================= ì„ íƒ ì ìš© ================= */
  const applySelection = (
    x0: number,
    y0: number,
    x1: number,
    y1: number,
    append: boolean
  ) => {
    const minX = Math.min(x0, x1);
    const maxX = Math.max(x0, x1);
    const minY = Math.min(y0, y1);
    const maxY = Math.max(y0, y1);

    const nextSelected = append
      ? new Set(selectedRef.current)
      : new Set<CellKey>();

    const selectedValues: number[] = [];

    y.forEach((yy, iy) => {
      if (yy < minY || yy > maxY) return;

      x.forEach((xx, ix) => {
        if (xx < minX || xx > maxX) return;

        const val = originalZ.current[iy][ix];
        if (Number.isNaN(val)) return;

        const key: CellKey = `${ix}-${iy}`;
        nextSelected.add(key);
        selectedValues.push(val);
      });
    });

    selectedRef.current = nextSelected;

    /* ===== z ì¬ìƒì„± ===== */
    const newZ = originalZ.current.map((row, iy) =>
      row.map((val, ix) =>
        selectedRef.current.has(`${ix}-${iy}`)
          ? 999 // ğŸ”¥ ì„ íƒ ìƒ‰ìƒìš© ê³ ì • ê°’
          : val
      )
    );

    setZ(newZ);

    console.log("ì„ íƒëœ ë°ì´í„°:", selectedValues);
  };

  /* ================= ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ================= */
  useEffect(() => {
    const wrapper = wrapperRef.current;
    if (!wrapper) return;

    const onMouseDown = (e: MouseEvent) => {
      if (e.shiftKey) return; // Shift = íŒ¨ë‹ ì „ìš©

      const plot = plotRef.current;
      if (!plot) return;

      isSelectingRef.current = true;
      startRef.current = pixelToData(e, plot);
    };

    const onMouseUp = (e: MouseEvent) => {
      if (!isSelectingRef.current) return;

      const plot = plotRef.current;
      if (!plot) return;

      const end = pixelToData(e, plot);

      applySelection(
        startRef.current.x,
        startRef.current.y,
        end.x,
        end.y,
        e.ctrlKey
      );

      isSelectingRef.current = false;
    };

    wrapper.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mouseup", onMouseUp);

    return () => {
      wrapper.removeEventListener("mousedown", onMouseDown);
      window.removeEventListener("mouseup", onMouseUp);
    };
  }, []);

  return (
    <div ref={wrapperRef} style={{ width: "100%", height: "500px" }}>
      <Plot
        data={[
          {
            type: "heatmap",
            x,
            y,
            z,
            colorscale: [
              [0, "#440154"],
              [0.9, "#21918c"],
              [1, "#ff0000"], // ğŸ”¥ ì„ íƒ ìƒ‰ìƒ
            ],
            zmax: 999,
            hoverongaps: false,
          },
        ]}
        layout={layout}
        config={config}
        style={{ width: "100%", height: "100%" }}
        onInitialized={(_, gd) => {
          plotRef.current = gd as PlotlyGraphDiv;
        }}
        onUpdate={(_, gd) => {
          plotRef.current = gd as PlotlyGraphDiv;
        }}
      />
    </div>
  );
};

export default WaferHeatmap;
