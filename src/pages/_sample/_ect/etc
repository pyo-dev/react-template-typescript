import Plot from 'react-plotly.js';
import Plotly from 'plotly.js-dist-min';
import { useEffect, useMemo, useRef, useState } from 'react';

type WaferData = [number, number, number];

interface Props {
  data: WaferData[];
}

export default function WaferHeatmap({ data }: Props) {
  const zRef = useRef<Float32Array | null>(null);
  const sizeRef = useRef<number>(0);
  const axisRangeRef = useRef<{ x?: [number, number]; y?: [number, number] }>({});
  const [revision, setRevision] = useState(0);

  /** 1Ô∏è‚É£ Îç∞Ïù¥ÌÑ∞ ‚Üí SIZE + Ïõ®Ïù¥Ìçº ÏÉùÏÑ± */
  useEffect(() => {
    if (!data || data.length === 0) return;

    let maxX = 0;
    let maxY = 0;
    let maxV = 0;

    for (const [x, y, v] of data) {
      maxX = Math.max(maxX, x);
      maxY = Math.max(maxY, y);
      maxV = Math.max(maxV, v);
    }

    const SIZE = Math.max(maxX, maxY) + 1;
    sizeRef.current = SIZE;

    const r = SIZE / 2;
    const z = new Float32Array(SIZE * SIZE);

    // Ïõ®Ïù¥Ìçº ÎßàÏä§ÌÅ¨
    for (let y = 0; y < SIZE; y++) {
      for (let x = 0; x < SIZE; x++) {
        const dx = x - r;
        const dy = y - r;
        z[y * SIZE + x] = Math.sqrt(dx * dx + dy * dy) <= r ? 0 : NaN;
      }
    }

    // Îç∞Ïù¥ÌÑ∞ Îß§Ìïë
    for (const [x, y, v] of data) {
      const idx = y * SIZE + x;
      if (!Number.isNaN(z[idx])) z[idx] = v;
    }

    zRef.current = z;
    setRevision(r => r + 1);
  }, [data]);

  /** 2Ô∏è‚É£ Ï§å ÏÉÅÌÉú Ï†ÄÏû• */
  const handleRelayout = (e: any) => {
    if (e['xaxis.range[0]'] !== undefined) {
      axisRangeRef.current.x = [e['xaxis.range[0]'], e['xaxis.range[1]']];
    }
    if (e['yaxis.range[0]'] !== undefined) {
      axisRangeRef.current.y = [e['yaxis.range[0]'], e['yaxis.range[1]']];
    }
  };

  /** 3Ô∏è‚É£ ÎìúÎûòÍ∑∏ ÏÖÄÎ†âÌä∏ */
  const handleSelected = (e: any) => {
    if (!e?.range || !zRef.current) return;

    const SIZE = sizeRef.current;
    const z = zRef.current;

    let [x0, x1] = e.range.x;
    let [y0, y1] = e.range.y;

    x0 = Math.floor(Math.max(0, x0));
    x1 = Math.floor(Math.min(SIZE - 1, x1));

    // yÏ∂ï Î∞òÏ†Ñ (reversed axis Í∏∞Ï§Ä)
    const ay0 = Math.floor(y0);
    const ay1 = Math.floor(y1);

    const selectValue = Math.max(...z.filter(v => !Number.isNaN(v))) + 1;

    for (let y = ay0; y <= ay1; y++) {
      for (let x = x0; x <= x1; x++) {
        const idx = y * SIZE + x;
        if (!Number.isNaN(z[idx])) z[idx] = selectValue;
      }
    }

    setRevision(r => r + 1);

    // üîí Ï§å Ïú†ÏßÄ (ÏïàÏ†ÑÌïú Î∞©Ïãù)
    requestAnimationFrame(() => {
      const gd = e?.event?.target;
      const { x, y } = axisRangeRef.current;
      if (gd && x && y) {
        Plotly.relayout(gd, {
          'xaxis.range': x,
          'yaxis.range': y,
        });
      }
    });
  };

  /** 4Ô∏è‚É£ 2D Î≥ÄÌôò */
  const z2D = useMemo(() => {
    if (!zRef.current) return [];
    const SIZE = sizeRef.current;
    const z = zRef.current;
    return Array.from({ length: SIZE }, (_, i) =>
      Array.from(z.slice(i * SIZE, (i + 1) * SIZE)),
    );
  }, [revision]);

  if (!zRef.current) return null;

  const SIZE = sizeRef.current;

  return (
    <Plot
      data={[
        {
          type: 'heatmap',
          z: z2D,
          hoverinfo: 'skip',
          colorscale: [
            [0, '#111827'],
            [0.7, '#22c55e'],
            [1, '#ef4444'],
          ],
        },
      ]}
      layout={{
        width: 600,
        height: 600,
        dragmode: 'select',
        xaxis: {
          range: [0, SIZE],
          visible: false,
          autorange: false,
        },
        yaxis: {
          range: [0, SIZE],
          autorange: 'reversed', // üî• ÌïµÏã¨
          visible: false,
          scaleanchor: 'x',
        },
        margin: { l: 0, r: 0, t: 0, b: 0 },
      }}
      config={{ displayModeBar: false }}
      revision={revision}
      onRelayout={handleRelayout}
      onSelected={handleSelected}
    />
  );
}
