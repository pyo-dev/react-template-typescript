import React, { useEffect, useRef, useState } from "react";

type DataPoint = [number, number, number];

interface Props {
  data: DataPoint[];
  fontColor?: string;
  fontColorSelected?: string;
  onSelectionChange?: (selected: DataPoint[]) => void;
}

export default function WaferHeatmap({
  data,
  fontColor = "#000",
  fontColorSelected = "#fff",
  onSelectionChange,
}: Props) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const wrapperRef = useRef<HTMLDivElement>(null);
  const metaRef = useRef({ minX: 0, maxX: 0, minY: 0, maxY: 0, w: 0, h: 0 });
  const selectedCellsRef = useRef<Set<string>>(new Set());
  const dragRef = useRef({ startX: 0, startY: 0, endX: 0, endY: 0, dragging: false });
  const dragHappenedRef = useRef(false);
  const scaleRef = useRef(1);
  const offsetRef = useRef({ x: 0, y: 0 });

  const [tooltip, setTooltip] = useState<{ x: number; y: number; v: number; px: number; py: number } | null>(null);

  /* =========================
     META 계산
  ========================= */
  useEffect(() => {
    if (!data.length) return;
    const xs = data.map(d => d[0]);
    const ys = data.map(d => d[1]);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    metaRef.current = { minX, maxX, minY, maxY, w: maxX - minX + 1, h: maxY - minY + 1 };
  }, [data]);

  /* =========================
     ResizeObserver
  ========================= */
  useEffect(() => {
    const wrapper = wrapperRef.current;
    if (!wrapper) return;

    const resizeObserver = new ResizeObserver(() => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      const dpr = window.devicePixelRatio || 1;
      const width = wrapper.clientWidth;
      const height = wrapper.clientHeight;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;
      draw();
    });

    resizeObserver.observe(wrapper);
    return () => resizeObserver.disconnect();
  }, [data]);

  const getCellSize = () => {
    const canvas = canvasRef.current!;
    const { w, h } = metaRef.current;
    const size = Math.min(canvas.clientWidth, canvas.clientHeight);
    const dpr = window.devicePixelRatio || 1;
    const raw = size / Math.max(w, h);
    return Math.max(1, Math.floor(raw * dpr) / dpr);
  };

  /* =========================
     DRAW
  ========================= */
  const draw = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d")!;
    const width = canvas.width;
    const height = canvas.height;

    ctx.clearRect(0, 0, width, height); // 잔상 제거

    ctx.save();
    ctx.setTransform(scaleRef.current, 0, 0, scaleRef.current, offsetRef.current.x, offsetRef.current.y);

    const { minX, maxY, w, h } = metaRef.current;
    const cell = getCellSize();

    const totalWidth = w * cell;
    const totalHeight = h * cell;
    const xOffset = (width / scaleRef.current - totalWidth) / 2;
    const yOffset = (height / scaleRef.current - totalHeight) / 2;

    // heatmap + 텍스트
    for (const [x, y, v] of data) {
      const gx = x - minX;
      const gy = maxY - y;
      const key = `${x},${y}`;

      ctx.fillStyle = selectedCellsRef.current.has(key)
        ? "rgba(255,0,0,0.7)"
        : `hsl(${240 - v * 2},80%,50%)`;
      ctx.fillRect(xOffset + gx * cell, yOffset + gy * cell, cell, cell);

      ctx.fillStyle = selectedCellsRef.current.has(key) ? fontColorSelected : fontColor;
      ctx.font = `${Math.floor(cell * 0.5)}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(v.toString(), xOffset + gx * cell + cell / 2, yOffset + gy * cell + cell / 2);
    }

    // grid line
    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (const [x, y] of data) {
      const gx = x - minX;
      const gy = maxY - y;
      const left = xOffset + gx * cell + 0.5;
      const top = yOffset + gy * cell + 0.5;
      const right = left + cell - 1;
      const bottom = top + cell - 1;
      ctx.moveTo(left, top); ctx.lineTo(right, top);
      ctx.moveTo(left, bottom); ctx.lineTo(right, bottom);
      ctx.moveTo(left, top); ctx.lineTo(left, bottom);
      ctx.moveTo(right, top); ctx.lineTo(right, bottom);
    }
    ctx.stroke();

    // 드래그 overlay
    if (dragRef.current.dragging && !(window.event as MouseEvent)?.shiftKey) {
      const { startX, startY, endX, endY } = dragRef.current;
      ctx.fillStyle = "rgba(0,120,255,0.25)";
      ctx.strokeStyle = "rgba(0,120,255,0.9)";
      ctx.lineWidth = 1;
      ctx.fillRect(
        Math.min(startX, endX) / scaleRef.current - offsetRef.current.x / scaleRef.current,
        Math.min(startY, endY) / scaleRef.current - offsetRef.current.y / scaleRef.current,
        Math.abs(endX - startX) / scaleRef.current,
        Math.abs(endY - startY) / scaleRef.current
      );
      ctx.strokeRect(
        Math.min(startX, endX) / scaleRef.current - offsetRef.current.x / scaleRef.current,
        Math.min(startY, endY) / scaleRef.current - offsetRef.current.y / scaleRef.current,
        Math.abs(endX - startX) / scaleRef.current,
        Math.abs(endY - startY) / scaleRef.current
      );
    }

    ctx.restore();
  };

  /* =========================
     MOUSE HANDLERS
  ========================= */
  const handleMove = (e: React.MouseEvent) => {
    const canvas = canvasRef.current!;
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const { minX, maxY, w, h } = metaRef.current;
    const cell = getCellSize();
    const totalWidth = w * cell;
    const totalHeight = h * cell;
    const xOffset = (canvas.clientWidth / scaleRef.current - totalWidth) / 2;
    const yOffset = (canvas.clientHeight / scaleRef.current - totalHeight) / 2;

    const localX = (mouseX - offsetRef.current.x) / scaleRef.current;
    const localY = (mouseY - offsetRef.current.y) / scaleRef.current;
    const gx = Math.floor((localX - xOffset) / cell);
    const gy = Math.floor((localY - yOffset) / cell);
    const dataX = minX + gx;
    const dataY = maxY - gy;

    const found = data.find(d => d[0] === dataX && d[1] === dataY);
    setTooltip(found ? { x: dataX, y: dataY, v: found[2], px: mouseX, py: mouseY } : null);

    if (!dragRef.current.dragging) return;

    if (e.shiftKey && scaleRef.current !== 1) {
      // 패닝 처리
      offsetRef.current.x += mouseX - dragRef.current.startX;
      offsetRef.current.y += mouseY - dragRef.current.startY;
      dragRef.current.startX = mouseX;
      dragRef.current.startY = mouseY;
      dragHappenedRef.current = true; // 패닝도 드래그로 처리
      draw();
      return;
    }

    // 드래그 선택
    dragHappenedRef.current = true;
    dragRef.current.endX = mouseX;
    dragRef.current.endY = mouseY;

    for (const [dx, dy] of data) {
      const cellX = xOffset + (dx - minX) * cell;
      const cellY = yOffset + (maxY - dy) * cell;
      const x0 = (Math.min(dragRef.current.startX, dragRef.current.endX) - offsetRef.current.x) / scaleRef.current;
      const x1 = (Math.max(dragRef.current.startX, dragRef.current.endX) - offsetRef.current.x) / scaleRef.current;
      const y0 = (Math.min(dragRef.current.startY, dragRef.current.endY) - offsetRef.current.y) / scaleRef.current;
      const y1 = (Math.max(dragRef.current.startY, dragRef.current.endY) - offsetRef.current.y) / scaleRef.current;

      if (cellX + cell >= x0 && cellX <= x1 && cellY + cell >= y0 && cellY <= y1) {
        selectedCellsRef.current.add(`${dx},${dy}`);
      }
    }
    draw();
  };

  const handleDown = (e: React.MouseEvent) => {
    dragHappenedRef.current = false;
    const rect = canvasRef.current!.getBoundingClientRect();
    dragRef.current = {
      startX: e.clientX - rect.left,
      startY: e.clientY - rect.top,
      endX: e.clientX - rect.left,
      endY: e.clientY - rect.top,
      dragging: true
    };
  };

  const handleUp = () => {
    dragRef.current.dragging = false;
    if (!dragHappenedRef.current) return; // 드래그 없으면 선택 처리 안함
    draw();
    if (onSelectionChange) {
      const selectedData = data.filter(d => selectedCellsRef.current.has(`${d[0]},${d[1]}`));
      onSelectionChange(selectedData);
    }
    dragHappenedRef.current = false;
  };

  const handleClick = (e: React.MouseEvent) => {
    if (dragHappenedRef.current) return; // 드래그/패닝 후 클릭 무시

    const canvas = canvasRef.current!;
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const { minX, maxY, w, h } = metaRef.current;
    const cell = getCellSize();
    const totalWidth = w * cell;
    const totalHeight = h * cell;
    const xOffset = (canvas.clientWidth / scaleRef.current - totalWidth) / 2;
    const yOffset = (canvas.clientHeight / scaleRef.current - totalHeight) / 2;

    const localX = (mouseX - offsetRef.current.x) / scaleRef.current;
    const localY = (mouseY - offsetRef.current.y) / scaleRef.current;
    const gx = Math.floor((localX - xOffset) / cell);
    const gy = Math.floor((localY - yOffset) / cell);
    const dataX = minX + gx;
    const dataY = maxY - gy;

    const key = `${dataX},${dataY}`;
    if (!data.find(d => d[0] === dataX && d[1] === dataY)) return;

    if (selectedCellsRef.current.has(key)) selectedCellsRef.current.delete(key);
    else selectedCellsRef.current.add(key);

    draw();

    if (onSelectionChange) {
      const selectedData = data.filter(d => selectedCellsRef.current.has(`${d[0]},${d[1]}`));
      onSelectionChange(selectedData);
    }
  };

  const handleWheel = (e: React.WheelEvent) => {
    if (!e.shiftKey) return;
    e.preventDefault();

    const canvas = canvasRef.current!;
    const cell = getCellSize();
    const { w, h } = metaRef.current;

    const delta = -e.deltaY;
    const factor = 1.05;
    let newScale = scaleRef.current * (delta > 0 ? factor : 1 / factor);

    const minScale = Math.min(1, canvas.clientWidth / (w * cell), canvas.clientHeight / (h * cell));
    newScale = Math.max(minScale, Math.min(newScale, 10));

    scaleRef.current = newScale;
    draw();
  };

  return (
    <div
      ref={wrapperRef}
      style={{ width: "100%", height: "100%", position: "relative" }}
      onWheel={handleWheel}
    >
      <canvas
        ref={canvasRef}
        onMouseMove={handleMove}
        onMouseDown={handleDown}
        onMouseUp={handleUp}
        onClick={handleClick}
        onMouseLeave={() => { setTooltip(null); dragRef.current.dragging = false; draw(); }}
      />
      {tooltip && (
        <div style={{ position: "absolute", left: tooltip.px + 10, top: tooltip.py + 10, background: "#111", color: "#fff", fontSize: 12, padding: "4px 6px", borderRadius: 4, pointerEvents: "none", whiteSpace: "nowrap" }}>
          x:{tooltip.x} y:{tooltip.y} v:{tooltip.v}
        </div>
      )}
    </div>
  );
}
