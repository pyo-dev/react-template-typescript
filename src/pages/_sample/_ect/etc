import React, { useEffect, useRef, useState } from "react";

type WaferRow = number[];

interface Props {
  data: WaferRow[];
  onSelectionChange?: (rows: WaferRow[]) => void;
}

export default function WaferCanvas({ data, onSelectionChange }: Props) {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const wrapperRef = useRef<HTMLDivElement | null>(null);

  /** ======================
   * 상태 Ref
   * ====================== */
  const metaRef = useRef<any>(null);
  const selectedRef = useRef<Set<string>>(new Set());

  const viewRef = useRef({
    scale: 1,
    offsetX: 0,
    offsetY: 0,
  });

  const actionRef = useRef<{
    type: "NONE" | "CLICK" | "DRAG_SELECT" | "PAN";
    moved: boolean;
  }>({ type: "NONE", moved: false });

  const dragRef = useRef({
    dragging: false,
    sx: 0,
    sy: 0,
    ex: 0,
    ey: 0,
  });

  const [tooltip, setTooltip] = useState<{
    x: number;
    y: number;
    row: WaferRow;
  } | null>(null);

  /** ======================
   * 메타 계산
   * ====================== */
  useEffect(() => {
    if (!data.length) return;

    const xs = data.map(d => d[0]);
    const ys = data.map(d => d[1]);

    metaRef.current = {
      minX: Math.min(...xs),
      maxX: Math.max(...xs),
      minY: Math.min(...ys),
      maxY: Math.max(...ys),
    };

    draw();
  }, [data]);

  /** ======================
   * Resize
   * ====================== */
  useEffect(() => {
    if (!wrapperRef.current) return;
    const ro = new ResizeObserver(draw);
    ro.observe(wrapperRef.current);
    return () => ro.disconnect();
  }, []);

  /** ======================
   * draw
   * ====================== */
  const draw = () => {
    const canvas = canvasRef.current;
    const wrapper = wrapperRef.current;
    const meta = metaRef.current;
    if (!canvas || !wrapper || !meta) return;

    const ctx = canvas.getContext("2d")!;
    const size = Math.min(wrapper.clientWidth, wrapper.clientHeight);

    canvas.width = size;
    canvas.height = size;

    const cols = meta.maxX - meta.minX + 1;
    const rows = meta.maxY - meta.minY + 1;

    const baseCell = Math.floor(
      Math.min(size / cols, size / rows)
    );

    const cell = baseCell * viewRef.current.scale;

    const ox =
      (size - cols * cell) / 2 + viewRef.current.offsetX;
    const oy =
      (size - rows * cell) / 2 + viewRef.current.offsetY;

    ctx.clearRect(0, 0, size, size);

    for (const row of data) {
      const xVal = row[0];
      const yVal = row[1];
      const v = row[2];

      const cx = xVal - meta.minX;
      const cy = meta.maxY - yVal;

      const x = ox + cx * cell;
      const y = oy + cy * cell;

      const key = `${xVal},${yVal}`;

      ctx.fillStyle = selectedRef.current.has(key)
        ? "#ff9800"
        : getColor(v);

      ctx.fillRect(x, y, cell, cell);

      ctx.strokeStyle = "#222";
      ctx.strokeRect(x, y, cell, cell);

      ctx.fillStyle = selectedRef.current.has(key)
        ? "#000"
        : "#fff";

      ctx.font = `${Math.max(10, cell * 0.4)}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(v), x + cell / 2, y + cell / 2);
    }

    /** 드래그 오버레이 */
    if (
      dragRef.current.dragging &&
      actionRef.current.type === "DRAG_SELECT"
    ) {
      ctx.save();
      ctx.strokeStyle = "#00e5ff";
      ctx.setLineDash([6, 4]);
      ctx.strokeRect(
        dragRef.current.sx,
        dragRef.current.sy,
        dragRef.current.ex - dragRef.current.sx,
        dragRef.current.ey - dragRef.current.sy
      );
      ctx.restore();
    }
  };

  /** ======================
   * 색상
   * ====================== */
  const getColor = (v: number) => {
    const t = Math.max(0, Math.min(1, v / 100));
    return `rgb(${255 * t},0,${255 * (1 - t)})`;
  };

  /** ======================
   * 좌표 → 셀
   * ====================== */
  const pointToCell = (mx: number, my: number) => {
    const canvas = canvasRef.current!;
    const meta = metaRef.current!;
    const size = canvas.width;

    const cols = meta.maxX - meta.minX + 1;
    const rows = meta.maxY - meta.minY + 1;

    const baseCell = Math.floor(
      Math.min(size / cols, size / rows)
    );
    const cell = baseCell * viewRef.current.scale;

    const ox =
      (size - cols * cell) / 2 + viewRef.current.offsetX;
    const oy =
      (size - rows * cell) / 2 + viewRef.current.offsetY;

    const cx = Math.floor((mx - ox) / cell);
    const cy = Math.floor((my - oy) / cell);

    return {
      x: meta.minX + cx,
      y: meta.maxY - cy,
      cx,
      cy,
    };
  };

  /** ======================
   * 마우스 이벤트
   * ====================== */
  const onDown = (e: React.MouseEvent) => {
    actionRef.current.moved = false;

    dragRef.current = {
      dragging: true,
      sx: e.nativeEvent.offsetX,
      sy: e.nativeEvent.offsetY,
      ex: e.nativeEvent.offsetX,
      ey: e.nativeEvent.offsetY,
    };

    actionRef.current.type = e.shiftKey ? "PAN" : "DRAG_SELECT";
  };

  const onMove = (e: React.MouseEvent) => {
    if (!dragRef.current.dragging) {
      const { x, y } = pointToCell(
        e.nativeEvent.offsetX,
        e.nativeEvent.offsetY
      );
      const found = data.find(d => d[0] === x && d[1] === y);
      setTooltip(
        found
          ? { x: e.clientX, y: e.clientY, row: found }
          : null
      );
      return;
    }

    actionRef.current.moved = true;

    if (actionRef.current.type === "PAN") {
      viewRef.current.offsetX += e.movementX;
      viewRef.current.offsetY += e.movementY;
      draw();
      return;
    }

    dragRef.current.ex = e.nativeEvent.offsetX;
    dragRef.current.ey = e.nativeEvent.offsetY;
    draw();
  };

  const onUp = () => {
    if (
      actionRef.current.type === "DRAG_SELECT" &&
      actionRef.current.moved
    ) {
      const { sx, sy, ex, ey } = dragRef.current;
      const minX = Math.min(sx, ex);
      const maxX = Math.max(sx, ex);
      const minY = Math.min(sy, ey);
      const maxY = Math.max(sy, ey);

      for (const row of data) {
        const p = pointToCell(
          (row[0] - metaRef.current.minX + 0.5) *
            (canvasRef.current!.width /
              (metaRef.current.maxX -
                metaRef.current.minX +
                1)),
          (metaRef.current.maxY - row[1] + 0.5) *
            (canvasRef.current!.height /
              (metaRef.current.maxY -
                metaRef.current.minY +
                1))
        );
        if (
          p.cx >= 0 &&
          p.cy >= 0 &&
          p.cx < 9999 &&
          p.cy < 9999
        ) {
          const key = `${row[0]},${row[1]}`;
          selectedRef.current.add(key);
        }
      }
      onSelectionChange?.(
        data.filter(d =>
          selectedRef.current.has(`${d[0]},${d[1]}`)
        )
      );
    }

    dragRef.current.dragging = false;
    actionRef.current.type = "NONE";
    draw();
  };

  const onWheel = (e: React.WheelEvent) => {
    if (!e.shiftKey) return;
    e.preventDefault();
    viewRef.current.scale *= e.deltaY > 0 ? 0.9 : 1.1;
    viewRef.current.scale = Math.max(
      0.5,
      Math.min(5, viewRef.current.scale)
    );
    draw();
  };

  return (
    <div
      ref={wrapperRef}
      style={{ width: "100%", height: "100%", position: "relative" }}
    >
      <canvas
        ref={canvasRef}
        onMouseDown={onDown}
        onMouseMove={onMove}
        onMouseUp={onUp}
        onWheel={onWheel}
        style={{ display: "block" }}
      />

      {tooltip && (
        <div
          style={{
            position: "fixed",
            left: tooltip.x + 12,
            top: tooltip.y + 12,
            background: "#000",
            color: "#fff",
            padding: 6,
            fontSize: 12,
            pointerEvents: "none",
          }}
        >
          {tooltip.row.map((v, i) => (
            <div key={i}>
              {i === 0
                ? "x"
                : i === 1
                ? "y"
                : i === 2
                ? "v"
                : `d${i}`}
              : {v}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
