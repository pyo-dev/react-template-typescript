import Plot from 'react-plotly.js';
import Plotly from 'plotly.js-dist-min';
import { useEffect, useMemo, useRef, useState } from 'react';

type WaferData = [number, number, number];

interface Props {
  data: WaferData[];
}

export default function WaferHeatmap({ data }: Props) {
  const zRef = useRef<Float32Array | null>(null);
  const sizeRef = useRef<number>(0);
  const plotRef = useRef<any>(null);

  const axisRangeRef = useRef<{
    x?: [number, number];
    y?: [number, number];
  }>({});

  const [revision, setRevision] = useState(0);

  /** 1Ô∏è‚É£ data ‚Üí SIZE Í≥ÑÏÇ∞ + Ïõ®Ïù¥Ìçº ÏÉùÏÑ± */
  useEffect(() => {
    if (!data || data.length === 0) return;

    let maxX = 0;
    let maxY = 0;
    let maxV = 0;

    for (const [x, y, v] of data) {
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (v > maxV) maxV = v;
    }

    const SIZE = Math.max(maxX, maxY) + 1;
    sizeRef.current = SIZE;

    const SELECT_VALUE = maxV + 1;

    const r = SIZE / 2;
    const z = new Float32Array(SIZE * SIZE);

    /** Ïõ®Ïù¥Ìçº ÏõêÌòï ÎßàÏä§ÌÅ¨ */
    for (let y = 0; y < SIZE; y++) {
      for (let x = 0; x < SIZE; x++) {
        const dx = x - r;
        const dy = y - r;
        const dist = Math.sqrt(dx * dx + dy * dy);
        z[y * SIZE + x] = dist <= r ? 0 : NaN;
      }
    }

    /** API Îç∞Ïù¥ÌÑ∞ Îß§Ìïë */
    for (const [x, y, v] of data) {
      const idx = y * SIZE + x;
      if (!Number.isNaN(z[idx])) {
        z[idx] = v;
      }
    }

    zRef.current = z;
    setRevision(r => r + 1);
  }, [data]);

  /** 2Ô∏è‚É£ Ï§å ÏÉÅÌÉú Ï†ÄÏû• */
  const handleRelayout = (e: any) => {
    if (e['xaxis.range[0]'] !== undefined) {
      axisRangeRef.current.x = [
        e['xaxis.range[0]'],
        e['xaxis.range[1]'],
      ];
    }
    if (e['yaxis.range[0]'] !== undefined) {
      axisRangeRef.current.y = [
        e['yaxis.range[0]'],
        e['yaxis.range[1]'],
      ];
    }
  };

  /** 3Ô∏è‚É£ ÎìúÎûòÍ∑∏ ÏÖÄÎ†âÌä∏ (Ï¢åÌëú Î≥¥Ï†ï Ìè¨Ìï®) */
  const handleSelected = (e: any) => {
    if (!e?.range || !zRef.current) return;

    const SIZE = sizeRef.current;
    const z = zRef.current;

    let [x0, x1] = e.range.x;
    let [y0, y1] = e.range.y;

    x0 = Math.floor(Math.max(0, x0));
    x1 = Math.floor(Math.min(SIZE - 1, x1));

    // üî• Plotly yÏ∂ï ‚Üí Î∞∞Ïó¥ yÏ∂ï Î≥¥Ï†ï
    const ay0 = SIZE - 1 - Math.floor(y1);
    const ay1 = SIZE - 1 - Math.floor(y0);

    const SELECT_VALUE = Math.max(...z) + 1;

    for (let y = ay0; y <= ay1; y++) {
      for (let x = x0; x <= x1; x++) {
        const idx = y * SIZE + x;
        if (!Number.isNaN(z[idx])) {
          z[idx] = SELECT_VALUE;
        }
      }
    }

    setRevision(r => r + 1);

    /** üîí Ï§å Ïú†ÏßÄ */
    requestAnimationFrame(() => {
      const { x, y } = axisRangeRef.current;
      if (x && y && plotRef.current) {
        Plotly.relayout(plotRef.current, {
          'xaxis.range': x,
          'yaxis.range': y,
        });
      }
    });
  };

  /** 4Ô∏è‚É£ PlotlyÏö© 2D Î≥ÄÌôò */
  const z2D = useMemo(() => {
    if (!zRef.current) return [];
    const SIZE = sizeRef.current;
    const z = zRef.current;

    const arr: number[][] = new Array(SIZE);
    for (let i = 0; i < SIZE; i++) {
      arr[i] = Array.from(z.slice(i * SIZE, (i + 1) * SIZE));
    }
    return arr;
  }, [revision]);

  if (!zRef.current) return null;

  return (
    <Plot
      ref={plotRef}
      data={[
        {
          type: 'heatmap',
          z: z2D,
          hoverinfo: 'skip',
          colorscale: [
            [0, '#111827'],
            [0.7, '#22c55e'],
            [1, '#ef4444'], // ÏÑ†ÌÉù ÏòÅÏó≠
          ],
        },
      ]}
      layout={{
        width: 600,
        height: 600,
        dragmode: 'select',
        xaxis: {
          visible: false,
          autorange: false,
          constrain: 'domain',
        },
        yaxis: {
          visible: false,
          autorange: false,
          scaleanchor: 'x',
        },
        margin: { l: 0, r: 0, t: 0, b: 0 },
      }}
      config={{ displayModeBar: false }}
      revision={revision}
      onRelayout={handleRelayout}
      onSelected={handleSelected}
    />
  );
}
