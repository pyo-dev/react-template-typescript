import React, { useRef, useEffect, useState } from "react";

type DataPoint = [number, number, number];

interface Props {
  data: DataPoint[];
}

export default function WaferHeatmap({ data }: Props) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const wrapperRef = useRef<HTMLDivElement>(null);

  const metaRef = useRef<{
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;
    w: number;
    h: number;
    grid: (number | null)[][];
  } | null>(null);

  const [tooltip, setTooltip] = useState<{
    x: number;
    y: number;
    v: number;
    px: number;
    py: number;
  } | null>(null);

  const dragRef = useRef<{
    startX: number;
    startY: number;
    endX: number;
    endY: number;
    dragging: boolean;
  }>({ startX: 0, startY: 0, endX: 0, endY: 0, dragging: false });

  /* =========================
     데이터 → Grid 변환
  ========================= */
  useEffect(() => {
    if (!data.length) return;

    const xs = data.map(d => d[0]);
    const ys = data.map(d => d[1]);

    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);

    const w = maxX - minX + 1;
    const h = maxY - minY + 1;

    const grid: (number | null)[][] = Array.from({ length: h }, () =>
      Array(w).fill(null)
    );

    data.forEach(([x, y, v]) => {
      const gx = x - minX;
      const gy = maxY - y; // y 아래 → 위
      grid[gy][gx] = v;
    });

    metaRef.current = { minX, maxX, minY, maxY, w, h, grid };
    draw();
  }, [data]);

  /* =========================
     공통 Cell 계산 (중요)
  ========================= */
  const getCell = () => {
    const canvas = canvasRef.current!;
    const dpr = window.devicePixelRatio || 1;
    const size = Math.min(canvas.clientWidth, canvas.clientHeight);
    const { w, h } = metaRef.current!;
    const raw = size / Math.max(w, h);
    return Math.floor(raw * dpr) / dpr;
  };

  /* =========================
     Draw
  ========================= */
  const draw = () => {
    const canvas = canvasRef.current;
    if (!canvas || !metaRef.current) return;

    const ctx = canvas.getContext("2d")!;
    const dpr = window.devicePixelRatio || 1;

    const size = Math.min(
      canvas.clientWidth,
      canvas.clientHeight
    );

    canvas.width = size * dpr;
    canvas.height = size * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, size, size);

    const { w, h, grid } = metaRef.current;
    const cell = getCell();

    const ox = Math.floor((size - w * cell) / 2);
    const oy = Math.floor((size - h * cell) / 2);

    // 웨이퍼 마스크
    const cx = (w - 1) / 2;
    const cy = (h - 1) / 2;
    const r = (Math.min(w, h) - 1) / 2;

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const dx = x - cx;
        const dy = y - cy;
        if (dx * dx + dy * dy > r * r) continue;

        const v = grid[y][x];
        if (v == null) continue;

        ctx.fillStyle = `rgb(${255 - v * 2}, ${50}, ${v * 2})`;
        ctx.fillRect(
          ox + x * cell,
          oy + y * cell,
          cell,
          cell
        );
      }
    }

    // Grid line (선명)
    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i <= w; i++) {
      const x = ox + Math.round(i * cell) + 0.5;
      ctx.moveTo(x, oy);
      ctx.lineTo(x, oy + h * cell);
    }
    for (let i = 0; i <= h; i++) {
      const y = oy + Math.round(i * cell) + 0.5;
      ctx.moveTo(ox, y);
      ctx.lineTo(ox + w * cell, y);
    }
    ctx.stroke();

    // Drag overlay
    if (dragRef.current.dragging) {
      const { startX, startY, endX, endY } = dragRef.current;
      ctx.fillStyle = "rgba(0,120,255,0.2)";
      ctx.strokeStyle = "rgba(0,120,255,0.8)";
      ctx.fillRect(startX, startY, endX - startX, endY - startY);
      ctx.strokeRect(startX, startY, endX - startX, endY - startY);
    }
  };

  /* =========================
     Mouse Events
  ========================= */
  const onMove = (e: React.MouseEvent) => {
    if (!metaRef.current) return;
    const canvas = canvasRef.current!;
    const rect = canvas.getBoundingClientRect();

    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;

    const { minX, maxY, w, h, grid } = metaRef.current;
    const cell = getCell();
    const size = Math.min(canvas.clientWidth, canvas.clientHeight);

    const ox = Math.floor((size - w * cell) / 2);
    const oy = Math.floor((size - h * cell) / 2);

    const gx = Math.floor((px - ox) / cell);
    const gy = Math.floor((py - oy) / cell);

    if (gx < 0 || gy < 0 || gx >= w || gy >= h) {
      setTooltip(null);
      return;
    }

    const v = grid[gy][gx];
    if (v == null) {
      setTooltip(null);
      return;
    }

    setTooltip({
      x: minX + gx,
      y: maxY - gy,
      v,
      px,
      py
    });

    if (dragRef.current.dragging) {
      dragRef.current.endX = px;
      dragRef.current.endY = py;
      draw();
    }
  };

  const onDown = (e: React.MouseEvent) => {
    const rect = canvasRef.current!.getBoundingClientRect();
    dragRef.current = {
      startX: e.clientX - rect.left,
      startY: e.clientY - rect.top,
      endX: e.clientX - rect.left,
      endY: e.clientY - rect.top,
      dragging: true
    };
  };

  const onUp = () => {
    dragRef.current.dragging = false;
    draw();
  };

  useEffect(() => {
    const onResize = () => draw();
    window.addEventListener("resize", onResize);
    return () => window.removeEventListener("resize", onResize);
  }, []);

  return (
    <div ref={wrapperRef} style={{ width: "100%", height: "100%", position: "relative" }}>
      <canvas
        ref={canvasRef}
        style={{ width: "100%", height: "100%", display: "block" }}
        onMouseMove={onMove}
        onMouseDown={onDown}
        onMouseUp={onUp}
        onMouseLeave={() => setTooltip(null)}
      />
      {tooltip && (
        <div
          style={{
            position: "absolute",
            left: tooltip.px + 12,
            top: tooltip.py + 12,
            background: "#000",
            color: "#fff",
            padding: "4px 8px",
            fontSize: 12,
            borderRadius: 4,
            pointerEvents: "none",
            whiteSpace: "nowrap"
          }}
        >
          x: {tooltip.x}, y: {tooltip.y}, v: {tooltip.v}
        </div>
      )}
    </div>
  );
}
