import { useEffect, useRef, useState } from "react";
import Plot from "react-plotly.js";
import Plotly from "plotly.js-dist-min";
import type { Layout, Shape } from "plotly.js";

type PlotDiv = HTMLDivElement & { _fullLayout: any; layout: any };
type CellKey = `${number}-${number}`;

export default function WaferHeatmap() {
  const wrapperRef = useRef<HTMLDivElement>(null);
  const plotRef = useRef<PlotDiv | null>(null);

  const isPanning = useRef(false);
  const isSelecting = useRef(false);

  const panStart = useRef({ x: 0, y: 0 });
  const selectStart = useRef({ x: 0, y: 0 });

  /* ================= 데이터 ================= */
  const size = 200;
  const radius = 100;
  const x = Array.from({ length: size }, (_, i) => i - radius);
  const y = Array.from({ length: size }, (_, i) => i - radius);

  const baseZ = useRef(
    y.map((yy) =>
      x.map((xx) =>
        xx * xx + yy * yy <= radius * radius ? Math.random() * 10 : NaN
      )
    )
  );

  const selectedSet = useRef<Set<CellKey>>(new Set());
  const [selectedZ, setSelectedZ] = useState(
    y.map(() => x.map(() => NaN))
  );

  /* ================= layout (고정) ================= */
  const layoutRef = useRef<Partial<Layout>>({
    uirevision: "wafer-fixed",
    dragmode: false,
    margin: { t: 10, r: 10, b: 10, l: 10 },
    xaxis: {
      range: [-radius, radius],
      autorange: false,
      scaleanchor: "y",
      scaleratio: 1,
    },
    yaxis: {
      range: [-radius, radius],
      autorange: false,
      scaleanchor: "x",
      scaleratio: 1,
    },
    shapes: [],
  });

  /* ================= 유틸 ================= */
  const pixelToData = (e: MouseEvent, plot: PlotDiv) => {
    const fl = plot._fullLayout;
    const rect = plot.getBoundingClientRect();

    return {
      x: fl.xaxis.p2d(e.clientX - rect.left - fl.xaxis._offset),
      y: fl.yaxis.p2d(e.clientY - rect.top - fl.yaxis._offset),
    };
  };

  /* ================= 이벤트 ================= */
  useEffect(() => {
    const wrapper = wrapperRef.current!;
    const plot = plotRef.current!;

    const onWheel = (e: WheelEvent) => {
      if (!e.shiftKey) return;
      e.preventDefault();

      const [x0, x1] = plot.layout.xaxis.range;
      const [y0, y1] = plot.layout.yaxis.range;

      const rect = plot.getBoundingClientRect();
      const zoom = e.deltaY > 0 ? 1.15 : 0.85;

      const cx = x0 + ((e.clientX - rect.left) / rect.width) * (x1 - x0);
      const cy = y1 - ((e.clientY - rect.top) / rect.height) * (y1 - y0);

      Plotly.relayout(plot, {
        "xaxis.range": [cx - (cx - x0) * zoom, cx + (x1 - cx) * zoom],
        "yaxis.range": [cy - (cy - y0) * zoom, cy + (y1 - cy) * zoom],
        "xaxis.autorange": false,
        "yaxis.autorange": false,
      });
    };

    const onMouseDown = (e: MouseEvent) => {
      if (e.shiftKey) {
        isPanning.current = true;
        panStart.current = { x: e.clientX, y: e.clientY };
        return;
      }

      isSelecting.current = true;
      selectStart.current = pixelToData(e, plot);

      Plotly.relayout(plot, {
        shapes: [
          {
            type: "rect",
            xref: "x",
            yref: "y",
            x0: selectStart.current.x,
            y0: selectStart.current.y,
            x1: selectStart.current.x,
            y1: selectStart.current.y,
            fillcolor: "rgba(0,120,255,0.25)",
            line: { color: "#0078ff", width: 1 },
          } as Shape,
        ],
      });
    };

    const onMouseMove = (e: MouseEvent) => {
      if (isPanning.current) {
        const dx = e.clientX - panStart.current.x;
        const dy = e.clientY - panStart.current.y;
        panStart.current = { x: e.clientX, y: e.clientY };

        const [x0, x1] = plot.layout.xaxis.range;
        const [y0, y1] = plot.layout.yaxis.range;

        Plotly.relayout(plot, {
          "xaxis.range": [
            x0 - (dx / plot.clientWidth) * (x1 - x0),
            x1 - (dx / plot.clientWidth) * (x1 - x0),
          ],
          "yaxis.range": [
            y0 + (dy / plot.clientHeight) * (y1 - y0),
            y1 + (dy / plot.clientHeight) * (y1 - y0),
          ],
        });
        return;
      }

      if (!isSelecting.current) return;

      const cur = pixelToData(e, plot);
      Plotly.relayout(plot, {
        "shapes[0].x1": cur.x,
        "shapes[0].y1": cur.y,
      });
    };

    const onMouseUp = (e: MouseEvent) => {
      if (isPanning.current) {
        isPanning.current = false;
        return;
      }

      if (!isSelecting.current) return;

      const end = pixelToData(e, plot);
      const minX = Math.min(selectStart.current.x, end.x);
      const maxX = Math.max(selectStart.current.x, end.x);
      const minY = Math.min(selectStart.current.y, end.y);
      const maxY = Math.max(selectStart.current.y, end.y);

      if (!e.ctrlKey) selectedSet.current.clear();

      y.forEach((yy, iy) => {
        if (yy < minY || yy > maxY) return;
        x.forEach((xx, ix) => {
          if (xx < minX || xx > maxX) return;
          if (!Number.isNaN(baseZ.current[iy][ix])) {
            selectedSet.current.add(`${ix}-${iy}`);
          }
        });
      });

      setSelectedZ(
        y.map((_, iy) =>
          x.map((_, ix) =>
            selectedSet.current.has(`${ix}-${iy}`) ? 1 : NaN
          )
        )
      );

      Plotly.relayout(plot, { shapes: [] });
      isSelecting.current = false;
    };

    wrapper.addEventListener("wheel", onWheel, { passive: false });
    wrapper.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);

    return () => {
      wrapper.removeEventListener("wheel", onWheel);
      wrapper.removeEventListener("mousedown", onMouseDown);
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", onMouseUp);
    };
  }, []);

  return (
    <div ref={wrapperRef} style={{ width: "100%", height: 500 }}>
      <Plot
        data={[
          { type: "heatmap", x, y, z: baseZ.current },
          {
            type: "heatmap",
            x,
            y,
            z: selectedZ,
            showscale: false,
            colorscale: [[0, "rgba(0,0,0,0)"], [1, "red"]],
          },
        ]}
        layout={layoutRef.current}
        style={{ width: "100%", height: "100%" }}
        onInitialized={(_, gd) => (plotRef.current = gd as PlotDiv)}
      />
    </div>
  );
}
