import { useEffect, useRef, useState } from 'react';

type WaferData = [number, number, number];

interface Props {
  data: WaferData[];
  size?: number; // canvas px
}

export default function WaferCanvas({ data, size = 600 }: Props) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const scaleRef = useRef(1);
  const offsetRef = useRef({ x: 0, y: 0 });
  const dragRef = useRef<{ x: number; y: number } | null>(null);

  const gridRef = useRef<Float32Array | null>(null);
  const metaRef = useRef({ w: 0, h: 0, minX: 0, minY: 0 });

  const [, forceRender] = useState(0);

  /* 1️⃣ grid 생성 */
  useEffect(() => {
    if (!data.length) return;

    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    for (const [x, y] of data) {
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
    }

    const w = maxX - minX + 1;
    const h = maxY - minY + 1;

    metaRef.current = { w, h, minX, minY };

    const grid = new Float32Array(w * h);
    const cx = (w - 1) / 2;
    const cy = (h - 1) / 2;
    const r = Math.min(w, h) / 2;

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const dx = x - cx;
        const dy = y - cy;
        grid[y * w + x] = Math.sqrt(dx * dx + dy * dy) <= r ? 0 : NaN;
      }
    }

    for (const [x, y, v] of data) {
      const ix = x - minX;
      const iy = y - minY;
      const idx = iy * w + ix;
      if (!Number.isNaN(grid[idx])) grid[idx] = v;
    }

    gridRef.current = grid;
    forceRender(v => v + 1);
  }, [data]);

  /* 2️⃣ draw */
  const draw = () => {
    const canvas = canvasRef.current;
    const grid = gridRef.current;
    if (!canvas || !grid) return;

    const ctx = canvas.getContext('2d')!;
    const { w, h } = metaRef.current;

    ctx.setTransform(scaleRef.current, 0, 0, scaleRef.current, offsetRef.current.x, offsetRef.current.y);
    ctx.clearRect(-10000, -10000, 20000, 20000);

    const cell = size / Math.max(w, h);

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const v = grid[y * w + x];
        if (Number.isNaN(v)) continue;

        ctx.fillStyle =
          v > 5 ? '#ef4444' :
          v > 2 ? '#22c55e' :
          '#111827';

        ctx.fillRect(x * cell, y * cell, cell, cell);
      }
    }
  };

  useEffect(draw);

  /* 3️⃣ zoom */
  const onWheel = (e: React.WheelEvent) => {
    e.preventDefault();
    const delta = e.deltaY < 0 ? 1.1 : 0.9;
    scaleRef.current *= delta;
    draw();
  };

  /* 4️⃣ drag select */
  const onMouseDown = (e: React.MouseEvent) => {
    dragRef.current = { x: e.offsetX, y: e.offsetY };
  };

  const onMouseUp = (e: React.MouseEvent) => {
    if (!dragRef.current || !gridRef.current) return;

    const { w, h } = metaRef.current;
    const cell = size / Math.max(w, h);

    const x0 = Math.min(dragRef.current.x, e.offsetX) / scaleRef.current;
    const x1 = Math.max(dragRef.current.x, e.offsetX) / scaleRef.current;
    const y0 = Math.min(dragRef.current.y, e.offsetY) / scaleRef.current;
    const y1 = Math.max(dragRef.current.y, e.offsetY) / scaleRef.current;

    const ix0 = Math.floor(x0 / cell);
    const ix1 = Math.floor(x1 / cell);
    const iy0 = Math.floor(y0 / cell);
    const iy1 = Math.floor(y1 / cell);

    let maxV = 0;
    for (const v of gridRef.current) if (!Number.isNaN(v)) maxV = Math.max(maxV, v);
    const mark = maxV + 1;

    for (let y = iy0; y <= iy1; y++) {
      for (let x = ix0; x <= ix1; x++) {
        const idx = y * w + x;
        if (!Number.isNaN(gridRef.current[idx])) {
          gridRef.current[idx] = mark;
        }
      }
    }

    dragRef.current = null;
    draw();
  };

  return (
    <canvas
      ref={canvasRef}
      width={size}
      height={size}
      onWheel={onWheel}
      onMouseDown={onMouseDown}
      onMouseUp={onMouseUp}
      style={{ background: '#000', cursor: 'crosshair' }}
    />
  );
}
