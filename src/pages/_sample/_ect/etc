useEffect(() => {
  const chart = chartRef.current?.chart;
  if (!chart) return;

  const xAxis = chart.xAxis[0];
  const yAxis = chart.yAxis[0];

  // 초기값 저장
  const x0 = xAxis.getExtremes();
  const y0 = yAxis.getExtremes();

  const original = {
    xMin: x0.dataMin,
    xMax: x0.dataMax,
    yMin: y0.dataMin,
    yMax: y0.dataMax,
  };

  // 축 padding 완전 제거
  xAxis.update(
    {
      minPadding: 0,
      maxPadding: 0,
      startOnTick: false,
      endOnTick: false,
      softMin: original.xMin,
      softMax: original.xMax,
    },
    false
  );

  yAxis.update(
    {
      minPadding: 0,
      maxPadding: 0,
      startOnTick: false,
      endOnTick: false,
      softMin: original.yMin,
      softMax: original.yMax,
    },
    false
  );

  chart.redraw();

  const handleWheel = (e: WheelEvent) => {
    if (!e.shiftKey) return;
    e.preventDefault();

    const zoomFactor = 0.2;
    const isZoomIn = e.deltaY < 0;
    const direction = isZoomIn ? -1 : 1;

    /* -------------------- X축 ---------------------- */
    const extX = xAxis.getExtremes();
    const currXRange = extX.max - extX.min;

    const isFullX =
      extX.min <= original.xMin && extX.max >= original.xMax;

    if (!isZoomIn && isFullX) {
      // 전체 범위면 축소 금지 + 강제 원래범위로 고정
      xAxis.setExtremes(original.xMin, original.xMax, true, false);
    } else {
      let newMin = extX.min + (currXRange * zoomFactor * direction) / 2;
      let newMax = extX.max - (currXRange * zoomFactor * direction) / 2;

      if (newMin < original.xMin) newMin = original.xMin;
      if (newMax > original.xMax) newMax = original.xMax;

      xAxis.setExtremes(newMin, newMax, true, false);
    }

    /* -------------------- Y축 ---------------------- */
    const extY = yAxis.getExtremes();
    const currYRange = extY.max - extY.min;

    const isFullY =
      extY.min <= original.yMin && extY.max >= original.yMax;

    if (!isZoomIn && isFullY) {
      yAxis.setExtremes(original.yMin, original.yMax, true, false);
    } else {
      let newMin = extY.min + (currYRange * zoomFactor * direction) / 2;
      let newMax = extY.max - (currYRange * zoomFactor * direction) / 2;

      if (newMin < original.yMin) newMin = original.yMin;
      if (newMax > original.yMax) newMax = original.yMax;

      yAxis.setExtremes(newMin, newMax, true, false);
    }
  };

  const el = chart.container;
  el.addEventListener("wheel", handleWheel);

  return () => {
    el.removeEventListener("wheel", handleWheel);
  };
}, []);
