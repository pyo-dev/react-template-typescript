import { useEffect, useRef, useState } from "react";
import Plot from "react-plotly.js";
import Plotly from "plotly.js-dist-min";
import type { Layout, Config, Shape } from "plotly.js";

type PlotlyGraphDiv = HTMLDivElement & {
  layout: {
    xaxis: { range: [number, number]; autorange?: boolean };
    yaxis: { range: [number, number]; autorange?: boolean };
    shapes?: Shape[];
  };
};

type CellKey = `${number}-${number}`;

const WaferHeatmap = () => {
  const wrapperRef = useRef<HTMLDivElement>(null);
  const plotRef = useRef<PlotlyGraphDiv | null>(null);

  const isPanning = useRef(false);
  const isSelecting = useRef(false);

  const panStart = useRef({ x: 0, y: 0 });
  const selectStart = useRef({ x: 0, y: 0 });

  /* ================= 데이터 ================= */
  const R = 100;
  const x = Array.from({ length: 200 }, (_, i) => i - 100);
  const y = Array.from({ length: 200 }, (_, i) => i - 100);

  const originalZ = useRef(
    y.map((yy) =>
      x.map((xx) => (xx * xx + yy * yy <= R * R ? Math.random() * 10 : NaN))
    )
  );

  const selectedSet = useRef<Set<CellKey>>(new Set());
  const [selectedZ, setSelectedZ] = useState(
    y.map(() => x.map(() => NaN))
  );

  /* ================= layout / config ================= */
  const layout: Partial<Layout> = {
    uirevision: "wafer-fixed", // ⭐ 확대/패닝 유지 핵심
    dragmode: false,
    margin: { t: 20, r: 20, b: 20, l: 20 },
    xaxis: {
      range: [-100, 100],
      autorange: false,
      scaleanchor: "y",
      scaleratio: 1,
    },
    yaxis: {
      range: [-100, 100],
      autorange: false,
      scaleanchor: "x",
      scaleratio: 1,
    },
    shapes: [],
  };

  const config: Partial<Config> = {
    scrollZoom: false,
    doubleClick: false,
    displayModeBar: true,
  };

  /* ================= 이벤트 ================= */
  useEffect(() => {
    const wrapper = wrapperRef.current;
    if (!wrapper) return;

    const pixelToData = (e: MouseEvent, plot: PlotlyGraphDiv) => {
      const fl = (plot as any)._fullLayout;
      const rect = plot.getBoundingClientRect();
      return {
        x: fl.xaxis.p2d(e.clientX - rect.left - fl.xaxis._offset),
        y: fl.yaxis.p2d(e.clientY - rect.top - fl.yaxis._offset),
      };
    };

    const applySelection = (
      x0: number,
      y0: number,
      x1: number,
      y1: number,
      append: boolean
    ) => {
      const minX = Math.min(x0, x1);
      const maxX = Math.max(x0, x1);
      const minY = Math.min(y0, y1);
      const maxY = Math.max(y0, y1);

      const next = append
        ? new Set(selectedSet.current)
        : new Set<CellKey>();

      const values: number[] = [];

      y.forEach((yy, iy) => {
        if (yy < minY || yy > maxY) return;
        x.forEach((xx, ix) => {
          if (xx < minX || xx > maxX) return;
          const v = originalZ.current[iy][ix];
          if (Number.isNaN(v)) return;
          next.add(`${ix}-${iy}`);
          values.push(v);
        });
      });

      selectedSet.current = next;

      setSelectedZ(
        y.map((_, iy) =>
          x.map((_, ix) =>
            selectedSet.current.has(`${ix}-${iy}`) ? 1 : NaN
          )
        )
      );

      console.log("선택 데이터:", values);
    };

    const onWheel = (e: WheelEvent) => {
      if (!e.shiftKey) return;
      e.preventDefault();

      const plot = plotRef.current!;
      const rect = plot.getBoundingClientRect();
      const [x0, x1] = plot.layout.xaxis.range;
      const [y0, y1] = plot.layout.yaxis.range;

      const zoom = e.deltaY > 0 ? 1.15 : 0.85;
      const cx = x0 + ((e.clientX - rect.left) / rect.width) * (x1 - x0);
      const cy = y1 - ((e.clientY - rect.top) / rect.height) * (y1 - y0);

      Plotly.relayout(plot, {
        "xaxis.range": [cx - (cx - x0) * zoom, cx + (x1 - cx) * zoom],
        "yaxis.range": [cy - (cy - y0) * zoom, cy + (y1 - cy) * zoom],
        "xaxis.autorange": false,
        "yaxis.autorange": false,
      });
    };

    const onMouseDown = (e: MouseEvent) => {
      const plot = plotRef.current!;
      if (e.shiftKey) {
        isPanning.current = true;
        panStart.current = { x: e.clientX, y: e.clientY };
        return;
      }

      isSelecting.current = true;
      selectStart.current = pixelToData(e, plot);

      Plotly.relayout(plot, {
        shapes: [
          {
            type: "rect",
            xref: "x",
            yref: "y",
            ...selectStart.current,
            x1: selectStart.current.x,
            y1: selectStart.current.y,
            fillcolor: "rgba(0,120,255,0.2)",
            line: { color: "#0078ff", width: 1 },
          },
        ],
        "xaxis.autorange": false,
        "yaxis.autorange": false,
      });
    };

    const onMouseMove = (e: MouseEvent) => {
      const plot = plotRef.current!;
      if (isPanning.current) {
        const dx = e.clientX - panStart.current.x;
        const dy = e.clientY - panStart.current.y;
        panStart.current = { x: e.clientX, y: e.clientY };

        const [x0, x1] = plot.layout.xaxis.range;
        const [y0, y1] = plot.layout.yaxis.range;

        Plotly.relayout(plot, {
          "xaxis.range": [
            x0 - (dx / plot.clientWidth) * (x1 - x0),
            x1 - (dx / plot.clientWidth) * (x1 - x0),
          ],
          "yaxis.range": [
            y0 + (dy / plot.clientHeight) * (y1 - y0),
            y1 + (dy / plot.clientHeight) * (y1 - y0),
          ],
          "xaxis.autorange": false,
          "yaxis.autorange": false,
        });
        return;
      }

      if (isSelecting.current) {
        const cur = pixelToData(e, plot);
        const shape = plot.layout.shapes?.[0];
        if (!shape) return;

        Plotly.relayout(plot, {
          shapes: [{ ...shape, x1: cur.x, y1: cur.y }],
          "xaxis.autorange": false,
          "yaxis.autorange": false,
        });
      }
    };

    const onMouseUp = (e: MouseEvent) => {
      const plot = plotRef.current!;
      if (isPanning.current) {
        isPanning.current = false;
        return;
      }

      if (isSelecting.current) {
        const end = pixelToData(e, plot);
        applySelection(
          selectStart.current.x,
          selectStart.current.y,
          end.x,
          end.y,
          e.ctrlKey
        );

        Plotly.relayout(plot, {
          shapes: [],
          "xaxis.autorange": false,
          "yaxis.autorange": false,
        });

        isSelecting.current = false;
      }
    };

    wrapper.addEventListener("wheel", onWheel, { passive: false });
    wrapper.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);

    return () => {
      wrapper.removeEventListener("wheel", onWheel);
      wrapper.removeEventListener("mousedown", onMouseDown);
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", onMouseUp);
    };
  }, []);

  return (
    <div ref={wrapperRef} style={{ width: "100%", height: 500 }}>
      <Plot
        data={[
          { type: "heatmap", x, y, z: originalZ.current },
          {
            type: "heatmap",
            x,
            y,
            z: selectedZ,
            colorscale: [[0, "rgba(0,0,0,0)"], [1, "red"]],
            showscale: false,
          },
        ]}
        layout={layout}
        config={config}
        style={{ width: "100%", height: "100%" }}
        onInitialized={(_, gd) => (plotRef.current = gd as PlotlyGraphDiv)}
      />
    </div>
  );
};

export default WaferHeatmap;
