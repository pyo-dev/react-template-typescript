import { useEffect, useRef } from "react";
import Plot from "react-plotly.js";
import Plotly from "plotly.js-dist-min";
import type { Layout, Config } from "plotly.js";

/* ===== Plotly graphDiv 최소 타입 ===== */
type PlotlyGraphDiv = HTMLDivElement & {
  layout: {
    xaxis: { range?: [number, number] };
    yaxis: { range?: [number, number] };
  };
  data: Array<{
    x: number[];
    y: number[];
  }>;
};

const WaferHeatmap: React.FC = () => {
  const wrapperRef = useRef<HTMLDivElement | null>(null);
  const plotRef = useRef<PlotlyGraphDiv | null>(null);

  const isPanningRef = useRef(false);
  const lastPosRef = useRef({ x: 0, y: 0 });

  /* ================= 데이터 (예시) ================= */
  const R = 100;

  const x = Array.from({ length: 200 }, (_, i) => i - 100);
  const y = Array.from({ length: 200 }, (_, i) => i - 100);

  const z = y.map((yy) =>
    x.map((xx) => (xx * xx + yy * yy <= R * R ? Math.random() * 10 : null))
  );

  const data = [
    {
      type: "heatmap" as const,
      x,
      y,
      z,
      colorscale: "Viridis",
      hoverongaps: false,
    },
  ];

  /* ================= range 자동 계산 ================= */
  const xMin = Math.min(...x);
  const xMax = Math.max(...x);
  const yMin = Math.min(...y);
  const yMax = Math.max(...y);

  /* ================= layout ================= */
  const layout: Partial<Layout> = {
    dragmode: false,
    margin: { t: 20, r: 20, b: 20, l: 20 },
    xaxis: {
      autorange: false,
      range: [xMin, xMax],
      scaleanchor: "y",
      scaleratio: 1,
      zeroline: false,
    },
    yaxis: {
      autorange: false,
      range: [yMin, yMax],
      scaleanchor: "x",
      scaleratio: 1,
      zeroline: false,
    },
  };

  /* ================= config ================= */
  const config: Partial<Config> = {
    scrollZoom: false,
    displayModeBar: true,
    doubleClick: false,
  };

  /* ================= 커서 제어 ================= */
  const setCursor = (cursor: "default" | "grab" | "grabbing") => {
    const plot = plotRef.current;
    if (!plot) return;

    plot.style.cursor = cursor;
    plot
      .querySelectorAll<HTMLElement>(
        ".plotly, .cartesianlayer, .hoverlayer, svg"
      )
      .forEach((el) => {
        el.style.cursor = cursor;
      });
  };

  /* ================= 인터랙션 ================= */
  useEffect(() => {
    const wrapper = wrapperRef.current;
    if (!wrapper) return;

    /* ---------- Shift + Wheel (Zoom) ---------- */
    const onWheel = (e: WheelEvent) => {
      if (!e.shiftKey) return;

      e.preventDefault();

      const plot = plotRef.current;
      if (!plot) return;

      const rect = plot.getBoundingClientRect();
      const [x0, x1] = plot.layout.xaxis.range!;
      const [y0, y1] = plot.layout.yaxis.range!;

      const xSpan = x1 - x0;
      const ySpan = y1 - y0;

      const zoom = e.deltaY > 0 ? 1.15 : 0.85;

      const cx = x0 + (xSpan * (e.clientX - rect.left)) / rect.width;
      const cy = y1 - (ySpan * (e.clientY - rect.top)) / rect.height;

      Plotly.relayout(plot, {
        "xaxis.range": [
          cx - (cx - x0) * zoom,
          cx + (x1 - cx) * zoom,
        ],
        "yaxis.range": [
          cy - (cy - y0) * zoom,
          cy + (y1 - cy) * zoom,
        ],
      });
    };

    /* ---------- Shift + Drag (Pan) ---------- */
    const onMouseDown = (e: MouseEvent) => {
      if (!e.shiftKey) return;

      isPanningRef.current = true;
      lastPosRef.current = { x: e.clientX, y: e.clientY };
      setCursor("grabbing");
      e.preventDefault();
    };

    const onMouseMove = (e: MouseEvent) => {
      if (!isPanningRef.current) return;

      const plot = plotRef.current;
      if (!plot) return;

      const rect = plot.getBoundingClientRect();

      const dx = e.clientX - lastPosRef.current.x;
      const dy = e.clientY - lastPosRef.current.y;
      lastPosRef.current = { x: e.clientX, y: e.clientY };

      const [x0, x1] = plot.layout.xaxis.range!;
      const [y0, y1] = plot.layout.yaxis.range!;

      const xSpan = x1 - x0;
      const ySpan = y1 - y0;

      const moveX = -(dx / rect.width) * xSpan;
      const moveY = (dy / rect.height) * ySpan;

      Plotly.relayout(plot, {
        "xaxis.range": [x0 + moveX, x1 + moveX],
        "yaxis.range": [y0 + moveY, y1 + moveY],
      });
    };

    const onMouseUp = () => {
      if (!isPanningRef.current) return;
      isPanningRef.current = false;
      setCursor("grab");
    };

    /* ---------- Shift key 커서 ---------- */
    const onKeyDown = (e: KeyboardEvent) => {
      if (e.key === "Shift") setCursor("grab");
    };

    const onKeyUp = (e: KeyboardEvent) => {
      if (e.key === "Shift") setCursor("default");
    };

    wrapper.addEventListener("wheel", onWheel, { passive: false });
    wrapper.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);
    window.addEventListener("keydown", onKeyDown);
    window.addEventListener("keyup", onKeyUp);

    return () => {
      wrapper.removeEventListener("wheel", onWheel);
      wrapper.removeEventListener("mousedown", onMouseDown);
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", onMouseUp);
      window.removeEventListener("keydown", onKeyDown);
      window.removeEventListener("keyup", onKeyUp);
    };
  }, []);

  return (
    <div
      ref={wrapperRef}
      style={{
        width: "100%",
        height: "500px",
        overflow: "hidden",
        userSelect: "none",
      }}
    >
      <Plot
        data={data}
        layout={layout}
        config={config}
        style={{ width: "100%", height: "100%" }}
        onInitialized={(_, graphDiv) => {
          plotRef.current = graphDiv as PlotlyGraphDiv;
        }}
        onUpdate={(_, graphDiv) => {
          plotRef.current = graphDiv as PlotlyGraphDiv;
        }}
      />
    </div>
  );
};

export default WaferHeatmap;
