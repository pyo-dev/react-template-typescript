useEffect(() => {
  const el = wrapperRef.current;
  if (!el) return;

  const onMouseDown = (e) => {
    if (!e.shiftKey) return;

    isPanningRef.current = true;
    lastPosRef.current = { x: e.clientX, y: e.clientY };
    e.preventDefault();
  };

  const onMouseMove = (e) => {
    if (!isPanningRef.current) return;

    const plot = plotDivRef.current;
    if (!plot) return;

    const dx = e.clientX - lastPosRef.current.x;
    const dy = e.clientY - lastPosRef.current.y;

    lastPosRef.current = { x: e.clientX, y: e.clientY };

    const xLen = plot.data[0].x.length;
    const yLen = plot.data[0].y.length;

    const xRange = plot.layout.xaxis.range ?? [0, xLen - 1];
    const yRange = plot.layout.yaxis.range ?? [0, yLen - 1];

    // 픽셀 → 인덱스 변환 (감도 조절)
    const scale = 0.01;

    Plotly.relayout(plot, {
      "xaxis.range": [
        Math.max(0, xRange[0] - dx * scale),
        Math.min(xLen - 1, xRange[1] - dx * scale),
      ],
      "yaxis.range": [
        Math.max(0, yRange[0] + dy * scale),
        Math.min(yLen - 1, yRange[1] + dy * scale),
      ],
    });
  };

  const onMouseUp = () => {
    isPanningRef.current = false;
  };

  el.addEventListener("mousedown", onMouseDown);
  window.addEventListener("mousemove", onMouseMove);
  window.addEventListener("mouseup", onMouseUp);

  return () => {
    el.removeEventListener("mousedown", onMouseDown);
    window.removeEventListener("mousemove", onMouseMove);
    window.removeEventListener("mouseup", onMouseUp);
  };
}, []);
