import { useEffect, useRef } from 'react';

type WaferData = [number, number, number];

interface Props {
  data: WaferData[];
}

export default function WaferCanvas({ data }: Props) {
  const containerRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);

  const gridRef = useRef<Float32Array | null>(null);
  const metaRef = useRef({ w: 0, h: 0, minX: 0, minY: 0 });

  const scaleRef = useRef(1);
  const dragStartRef = useRef<{ x: number; y: number } | null>(null);

  /* ===============================
   * 1Ô∏è‚É£ API Îç∞Ïù¥ÌÑ∞ ‚Üí Grid ÏÉùÏÑ±
   * =============================== */
  useEffect(() => {
    if (!data.length) return;

    let minX = Infinity,
      maxX = -Infinity,
      minY = Infinity,
      maxY = -Infinity;

    for (const [x, y] of data) {
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
    }

    const w = maxX - minX + 1;
    const h = maxY - minY + 1;

    metaRef.current = { w, h, minX, minY };

    const grid = new Float32Array(w * h);

    const cx = (w - 1) / 2;
    const cy = (h - 1) / 2;
    const r = Math.min(w, h) / 2;

    // Ïõ®Ïù¥Ìçº ÏõêÌòï ÎßàÏä§ÌÅ¨
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const dx = x - cx;
        const dy = y - cy;
        grid[y * w + x] = Math.sqrt(dx * dx + dy * dy) <= r ? 0 : NaN;
      }
    }

    // Í∞í Îß§Ìïë
    for (const [x, y, v] of data) {
      const ix = x - minX;
      const iy = y - minY;
      const idx = iy * w + ix;
      if (!Number.isNaN(grid[idx])) grid[idx] = v;
    }

    gridRef.current = grid;
    draw();
  }, [data]);

  /* ===============================
   * 2Ô∏è‚É£ Draw (ÌîΩÏÖÄ Ïä§ÎÉÖ Ìè¨Ìï®)
   * =============================== */
  const draw = () => {
    const canvas = canvasRef.current;
    const container = containerRef.current;
    const grid = gridRef.current;
    if (!canvas || !container || !grid) return;

    const ctx = canvas.getContext('2d')!;
    const dpr = window.devicePixelRatio || 1;

    const size = Math.min(container.clientWidth, container.clientHeight);

    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;

    ctx.setTransform(dpr * scaleRef.current, 0, 0, dpr * scaleRef.current, 0, 0);
    ctx.clearRect(0, 0, size, size);

    const { w, h } = metaRef.current;

    // üî• cell ÌÅ¨Í∏∞ ÌîΩÏÖÄ Ïä§ÎÉÖ
    const rawCell = size / Math.max(w, h);
    const cell = Math.floor(rawCell * dpr) / dpr;

    /* ===== ÏÖÄ Ï±ÑÏö∞Í∏∞ ===== */
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const v = grid[y * w + x];
        if (Number.isNaN(v)) continue;

        if (v >= 10000) ctx.fillStyle = '#2563eb'; // ÏÑ†ÌÉù
        else if (v > 5) ctx.fillStyle = '#ef4444';
        else if (v > 2) ctx.fillStyle = '#22c55e';
        else ctx.fillStyle = '#111827';

        ctx.fillRect(x * cell, y * cell, cell, cell);
      }
    }

    /* ===== Í∑∏Î¶¨Îìú ÎùºÏù∏ (ÏôÑÏ†Ñ ÏÑ†Î™Ö) ===== */
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1 / dpr;

    const snap = (v: number) =>
      Math.round(v * dpr) / dpr + 0.5 / dpr;

    for (let x = 0; x <= w; x++) {
      const px = snap(x * cell);
      ctx.beginPath();
      ctx.moveTo(px, 0);
      ctx.lineTo(px, snap(h * cell));
      ctx.stroke();
    }

    for (let y = 0; y <= h; y++) {
      const py = snap(y * cell);
      ctx.beginPath();
      ctx.moveTo(0, py);
      ctx.lineTo(snap(w * cell), py);
      ctx.stroke();
    }

    ctx.restore();
  };

  /* ===============================
   * 3Ô∏è‚É£ Î∞òÏùëÌòï
   * =============================== */
  useEffect(() => {
    const ro = new ResizeObserver(draw);
    if (containerRef.current) ro.observe(containerRef.current);
    return () => ro.disconnect();
  }, []);

  /* ===============================
   * 4Ô∏è‚É£ Zoom
   * =============================== */
  const onWheel = (e: React.WheelEvent) => {
    e.preventDefault();
    scaleRef.current *= e.deltaY < 0 ? 1.1 : 0.9;
    scaleRef.current = Math.min(Math.max(scaleRef.current, 1), 8);
    draw();
  };

  /* ===============================
   * 5Ô∏è‚É£ Drag Select
   * =============================== */
  const onMouseDown = (e: React.MouseEvent) => {
    dragStartRef.current = {
      x: e.nativeEvent.offsetX,
      y: e.nativeEvent.offsetY,
    };
  };

  const onMouseUp = (e: React.MouseEvent) => {
    if (!dragStartRef.current || !gridRef.current) return;

    const { w, h } = metaRef.current;
    const size = canvasRef.current!.clientWidth;
    const rawCell = size / Math.max(w, h);
    const cell = Math.floor(rawCell * (window.devicePixelRatio || 1)) /
                 (window.devicePixelRatio || 1);

    const x0 =
      Math.min(dragStartRef.current.x, e.nativeEvent.offsetX) /
      scaleRef.current;
    const x1 =
      Math.max(dragStartRef.current.x, e.nativeEvent.offsetX) /
      scaleRef.current;
    const y0 =
      Math.min(dragStartRef.current.y, e.nativeEvent.offsetY) /
      scaleRef.current;
    const y1 =
      Math.max(dragStartRef.current.y, e.nativeEvent.offsetY) /
      scaleRef.current;

    const ix0 = Math.floor(x0 / cell);
    const ix1 = Math.floor(x1 / cell);
    const iy0 = Math.floor(y0 / cell);
    const iy1 = Math.floor(y1 / cell);

    for (let y = iy0; y <= iy1; y++) {
      for (let x = ix0; x <= ix1; x++) {
        const idx = y * w + x;
        if (!Number.isNaN(gridRef.current[idx])) {
          gridRef.current[idx] = 10000;
        }
      }
    }

    dragStartRef.current = null;
    draw();
  };

  return (
    <div
      ref={containerRef}
      style={{
        width: '100%',
        height: '100%',
        position: 'relative',
        overflow: 'hidden',
      }}
    >
      <canvas
        ref={canvasRef}
        onWheel={onWheel}
        onMouseDown={onMouseDown}
        onMouseUp={onMouseUp}
        style={{
          display: 'block',
          background: '#000',
          cursor: 'crosshair',
        }}
      />
    </div>
  );
}
