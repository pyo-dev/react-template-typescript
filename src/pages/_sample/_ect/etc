const testData10x10: [number, number, number][] = [
  // y = 29 (top)
  [10, 29, 1], [11, 29, 2], [12, 29, 3], [13, 29, 4], [14, 29, 5],
  [15, 29, 6], [16, 29, 7], [17, 29, 8], [18, 29, 9], [19, 29, 10],

  // y = 28
  [10, 28, 11], [11, 28, 12], [12, 28, 13], [13, 28, 14], [14, 28, 15],
  [15, 28, 16], [16, 28, 17], [17, 28, 18], [18, 28, 19], [19, 28, 20],

  // y = 27
  [10, 27, 21], [11, 27, 22], [12, 27, 23], [13, 27, 24], [14, 27, 25],
  [15, 27, 26], [16, 27, 27], [17, 27, 28], [18, 27, 29], [19, 27, 30],

  // y = 26
  [10, 26, 31], [11, 26, 32], [12, 26, 33], [13, 26, 34], [14, 26, 35],
  [15, 26, 36], [16, 26, 37], [17, 26, 38], [18, 26, 39], [19, 26, 40],

  // y = 25
  [10, 25, 41], [11, 25, 42], [12, 25, 43], [13, 25, 44], [14, 25, 45],
  [15, 25, 46], [16, 25, 47], [17, 25, 48], [18, 25, 49], [19, 25, 50],

  // y = 24
  [10, 24, 51], [11, 24, 52], [12, 24, 53], [13, 24, 54], [14, 24, 55],
  [15, 24, 56], [16, 24, 57], [17, 24, 58], [18, 24, 59], [19, 24, 60],

  // y = 23
  [10, 23, 61], [11, 23, 62], [12, 23, 63], [13, 23, 64], [14, 23, 65],
  [15, 23, 66], [16, 23, 67], [17, 23, 68], [18, 23, 69], [19, 23, 70],

  // y = 22
  [10, 22, 71], [11, 22, 72], [12, 22, 73], [13, 22, 74], [14, 22, 75],
  [15, 22, 76], [16, 22, 77], [17, 22, 78], [18, 22, 79], [19, 22, 80],

  // y = 21
  [10, 21, 81], [11, 21, 82], [12, 21, 83], [13, 21, 84], [14, 21, 85],
  [15, 21, 86], [16, 21, 87], [17, 21, 88], [18, 21, 89], [19, 21, 90],

  // y = 20 (bottom)
  [10, 20, 91], [11, 20, 92], [12, 20, 93], [13, 20, 94], [14, 20, 95],
  [15, 20, 96], [16, 20, 97], [17, 20, 98], [18, 20, 99], [19, 20, 100],
];



const testData: [number, number, number][] = [
  // y = 22 (Îß® ÏúÑ)
  [10, 22, 1],
  [11, 22, 2],
  [12, 22, 3],

  // y = 21 (Ï§ëÍ∞Ñ)
  [10, 21, 4],
  [11, 21, 5],
  [12, 21, 6],

  // y = 20 (Îß® ÏïÑÎûò)
  [10, 20, 7],
  [11, 20, 8],
  [12, 20, 9],
];


const testData10: [number, number, number][] = [
  // ÏÉÅÎã®
  [10, 29, 1],
  [11, 29, 2],
  [12, 29, 3],

  // Ï§ëÏÉÅÎã®
  [10, 28, 4],
  [11, 28, 5],

  // Ï§ëÏïô
  [11, 27, 6],

  // Ï§ëÌïòÎã®
  [10, 26, 7],
  [11, 26, 8],

  // ÌïòÎã®
  [11, 25, 9],
  [12, 25, 10],
];


import { useEffect, useRef, useState } from 'react';

type WaferData = [number, number, number];

interface Props {
  data: WaferData[];
}

export default function WaferCanvas({ data }: Props) {
  const containerRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);

  const gridRef = useRef<Float32Array | null>(null);
  const metaRef = useRef({
    w: 0,
    h: 0,
    minX: 0,
    minY: 0,
    maxY: 0,
  });

  const scaleRef = useRef(1);
  const dragStartRef = useRef<{ x: number; y: number } | null>(null);
  const dragCurrentRef = useRef<{ x: number; y: number } | null>(null);

  const [tooltip, setTooltip] = useState<{
    x: number;
    y: number;
    text: string;
  } | null>(null);

  /* ===============================
   * 1Ô∏è‚É£ API Îç∞Ïù¥ÌÑ∞ ‚Üí Grid (Y Î∞òÏ†Ñ)
   * =============================== */
  useEffect(() => {
    if (!data.length) return;

    let minX = Infinity,
      maxX = -Infinity,
      minY = Infinity,
      maxY = -Infinity;

    for (const [x, y] of data) {
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
    }

    const w = maxX - minX + 1;
    const h = maxY - minY + 1;

    metaRef.current = { w, h, minX, minY, maxY };

    const grid = new Float32Array(w * h);

    const cx = (w - 1) / 2;
    const cy = (h - 1) / 2;
    const r = Math.min(w, h) / 2;

    // Ïõ®Ïù¥Ìçº ÏõêÌòï ÎßàÏä§ÌÅ¨
    for (let gy = 0; gy < h; gy++) {
      for (let gx = 0; gx < w; gx++) {
        const dx = gx - cx;
        const dy = gy - cy;
        grid[gy * w + gx] =
          Math.sqrt(dx * dx + dy * dy) <= r ? 0 : NaN;
      }
    }

    // üî• Îç∞Ïù¥ÌÑ∞ Îß§Ìïë (Y Î∞òÏ†Ñ)
    for (const [x, y, v] of data) {
      const ix = x - minX;
      const iy = maxY - y; // ÌïµÏã¨
      const idx = iy * w + ix;
      if (!Number.isNaN(grid[idx])) grid[idx] = v;
    }

    gridRef.current = grid;
    draw();
  }, [data]);

  /* ===============================
   * 2Ô∏è‚É£ Draw
   * =============================== */
  const draw = () => {
    const canvas = canvasRef.current;
    const container = containerRef.current;
    const grid = gridRef.current;
    if (!canvas || !container || !grid) return;

    const ctx = canvas.getContext('2d')!;
    const dpr = window.devicePixelRatio || 1;

    const size = Math.min(container.clientWidth, container.clientHeight);

    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;

    ctx.setTransform(dpr * scaleRef.current, 0, 0, dpr * scaleRef.current, 0, 0);
    ctx.clearRect(0, 0, size, size);

    const { w, h } = metaRef.current;

    const rawCell = size / Math.max(w, h);
    const cell = Math.floor(rawCell * dpr) / dpr;

    // ÏÖÄ Î†åÎçî
    for (let gy = 0; gy < h; gy++) {
      for (let gx = 0; gx < w; gx++) {
        const v = grid[gy * w + gx];
        if (Number.isNaN(v)) continue;

        if (v >= 10000) ctx.fillStyle = '#2563eb';
        else if (v > 5) ctx.fillStyle = '#ef4444';
        else if (v > 2) ctx.fillStyle = '#22c55e';
        else ctx.fillStyle = '#111827';

        ctx.fillRect(gx * cell, gy * cell, cell, cell);
      }
    }

    // Í∑∏Î¶¨Îìú ÎùºÏù∏ (ÌîΩÏÖÄ Ïä§ÎÉÖ)
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1 / dpr;

    const snap = (v: number) =>
      Math.round(v * dpr) / dpr + 0.5 / dpr;

    for (let x = 0; x <= w; x++) {
      const px = snap(x * cell);
      ctx.beginPath();
      ctx.moveTo(px, 0);
      ctx.lineTo(px, snap(h * cell));
      ctx.stroke();
    }

    for (let y = 0; y <= h; y++) {
      const py = snap(y * cell);
      ctx.beginPath();
      ctx.moveTo(0, py);
      ctx.lineTo(snap(w * cell), py);
      ctx.stroke();
    }

    // ÎìúÎûòÍ∑∏ Ïò§Î≤ÑÎ†àÏù¥
    if (dragStartRef.current && dragCurrentRef.current) {
      const x = Math.min(dragStartRef.current.x, dragCurrentRef.current.x);
      const y = Math.min(dragStartRef.current.y, dragCurrentRef.current.y);
      const w = Math.abs(dragStartRef.current.x - dragCurrentRef.current.x);
      const h = Math.abs(dragStartRef.current.y - dragCurrentRef.current.y);

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = 'rgba(37,99,235,0.25)';
      ctx.strokeStyle = 'rgba(37,99,235,0.8)';
      ctx.lineWidth = 1;
      ctx.fillRect(x, y, w, h);
      ctx.strokeRect(x, y, w, h);
    }
  };

  /* ===============================
   * 3Ô∏è‚É£ Resize
   * =============================== */
  useEffect(() => {
    const ro = new ResizeObserver(draw);
    if (containerRef.current) ro.observe(containerRef.current);
    return () => ro.disconnect();
  }, []);

  /* ===============================
   * 4Ô∏è‚É£ Zoom
   * =============================== */
  const onWheel = (e: React.WheelEvent) => {
    e.preventDefault();
    scaleRef.current *= e.deltaY < 0 ? 1.1 : 0.9;
    scaleRef.current = Math.min(Math.max(scaleRef.current, 1), 8);
    draw();
  };

  /* ===============================
   * 5Ô∏è‚É£ Mouse
   * =============================== */
  const onMouseDown = (e: React.MouseEvent) => {
    dragStartRef.current = { x: e.nativeEvent.offsetX, y: e.nativeEvent.offsetY };
    dragCurrentRef.current = null;
  };

  const onMouseMove = (e: React.MouseEvent) => {
    if (dragStartRef.current) {
      dragCurrentRef.current = {
        x: e.nativeEvent.offsetX,
        y: e.nativeEvent.offsetY,
      };
      draw();
      return;
    }

    const grid = gridRef.current;
    if (!grid) return;

    const { w, h, minX, maxY } = metaRef.current;
    const size = canvasRef.current!.clientWidth;
    const cell = size / Math.max(w, h);

    const x = e.nativeEvent.offsetX / scaleRef.current;
    const y = e.nativeEvent.offsetY / scaleRef.current;

    const gx = Math.floor(x / cell);
    const gy = Math.floor(y / cell);

    if (gx < 0 || gy < 0 || gx >= w || gy >= h) {
      setTooltip(null);
      return;
    }

    const idx = gy * w + gx;
    const v = grid[idx];
    if (Number.isNaN(v)) {
      setTooltip(null);
      return;
    }

    const dataX = gx + minX;
    const dataY = maxY - gy; // üî• Îã§Ïãú Î∞òÏ†Ñ

    setTooltip({
      x: e.clientX + 12,
      y: e.clientY + 12,
      text: `x:${dataX}, y:${dataY}, v:${v}`,
    });
  };

  const onMouseUp = (e: React.MouseEvent) => {
    if (!dragStartRef.current || !gridRef.current) return;

    const { w, h } = metaRef.current;
    const size = canvasRef.current!.clientWidth;
    const cell = size / Math.max(w, h);

    const x0 =
      Math.min(dragStartRef.current.x, e.nativeEvent.offsetX) /
      scaleRef.current;
    const x1 =
      Math.max(dragStartRef.current.x, e.nativeEvent.offsetX) /
      scaleRef.current;
    const y0 =
      Math.min(dragStartRef.current.y, e.nativeEvent.offsetY) /
      scaleRef.current;
    const y1 =
      Math.max(dragStartRef.current.y, e.nativeEvent.offsetY) /
      scaleRef.current;

    for (let gy = Math.floor(y0 / cell); gy <= Math.floor(y1 / cell); gy++) {
      for (let gx = Math.floor(x0 / cell); gx <= Math.floor(x1 / cell); gx++) {
        const idx = gy * w + gx;
        if (!Number.isNaN(gridRef.current[idx])) {
          gridRef.current[idx] = 10000;
        }
      }
    }

    dragStartRef.current = null;
    dragCurrentRef.current = null;
    setTooltip(null);
    draw();
  };

  return (
    <div ref={containerRef} style={{ width: '100%', height: '100%' }}>
      <canvas
        ref={canvasRef}
        onWheel={onWheel}
        onMouseDown={onMouseDown}
        onMouseMove={onMouseMove}
        onMouseUp={onMouseUp}
        style={{ display: 'block', background: '#000' }}
      />

      {tooltip && (
        <div
          style={{
            position: 'fixed',
            left: tooltip.x,
            top: tooltip.y,
            background: 'rgba(0,0,0,0.85)',
            color: '#fff',
            fontSize: 12,
            padding: '4px 6px',
            borderRadius: 4,
            pointerEvents: 'none',
            whiteSpace: 'nowrap',
          }}
        >
          {tooltip.text}
        </div>
      )}
    </div>
  );
}
