import Plot from 'react-plotly.js';
import { useEffect, useMemo, useRef, useState } from 'react';
import axios from 'axios';

const SELECT_VALUE = 999;

export default function WaferHeatmap() {
  const zRef = useRef<Float32Array | null>(null);
  const sizeRef = useRef<number>(0);
  const [revision, setRevision] = useState(0);

  /** 1️⃣ API 데이터 로딩 */
  useEffect(() => {
    let mounted = true;

    axios.get<[number, number, number][]>('/api/wafer').then(res => {
      if (!mounted) return;

      const data = res.data;

      /** 2️⃣ size 계산 (max x,y 기준) */
      let maxX = 0;
      let maxY = 0;

      for (const [x, y] of data) {
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }

      const SIZE = Math.max(maxX, maxY) + 1;
      sizeRef.current = SIZE;

      /** 3️⃣ 웨이퍼 마스크 생성 */
      const r = SIZE / 2;
      const z = new Float32Array(SIZE * SIZE);

      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          const dx = x - r;
          const dy = y - r;
          const dist = Math.sqrt(dx * dx + dy * dy);
          z[y * SIZE + x] = dist <= r ? 0 : NaN;
        }
      }

      /** 4️⃣ API 값 매핑 */
      for (const [x, y, v] of data) {
        const idx = y * SIZE + x;
        if (!Number.isNaN(z[idx])) {
          z[idx] = v;
        }
      }

      zRef.current = z;
      setRevision(r => r + 1);
    });

    return () => {
      mounted = false;
    };
  }, []);

  /** 5️⃣ 드래그 영역 색칠 */
  const handleSelected = (e: any) => {
    if (!e?.range || !zRef.current) return;

    const SIZE = sizeRef.current;
    const z = zRef.current;
    const { x, y } = e.range;

    const x0 = Math.max(0, Math.floor(x[0]));
    const x1 = Math.min(SIZE - 1, Math.floor(x[1]));
    const y0 = Math.max(0, Math.floor(y[0]));
    const y1 = Math.min(SIZE - 1, Math.floor(y[1]));

    for (let yy = y0; yy <= y1; yy++) {
      for (let xx = x0; xx <= x1; xx++) {
        const idx = yy * SIZE + xx;
        if (!Number.isNaN(z[idx])) {
          z[idx] = SELECT_VALUE;
        }
      }
    }

    setRevision(r => r + 1);
  };

  /** 6️⃣ Plotly용 2D 변환 */
  const z2D = useMemo(() => {
    if (!zRef.current) return [];

    const SIZE = sizeRef.current;
    const z = zRef.current;
    const arr: number[][] = new Array(SIZE);

    for (let i = 0; i < SIZE; i++) {
      arr[i] = Array.from(z.slice(i * SIZE, (i + 1) * SIZE));
    }
    return arr;
  }, [revision]);

  if (!zRef.current) return null;

  return (
    <Plot
      data={[
        {
          type: 'heatmap',
          z: z2D,
          zmin: 0,
          zmax: SELECT_VALUE,
          hoverinfo: 'skip',
          colorscale: [
            [0, '#111827'],
            [0.7, '#22c55e'],
            [1, '#ef4444'], // 선택 영역
          ],
        },
      ]}
      layout={{
        width: 600,
        height: 600,
        dragmode: 'select',
        xaxis: { visible: false, constrain: 'domain' },
        yaxis: { visible: false, scaleanchor: 'x' },
        margin: { l: 0, r: 0, t: 0, b: 0 },
      }}
      config={{
        displayModeBar: false,
      }}
      revision={revision}
      onSelected={handleSelected}
    />
  );
}
