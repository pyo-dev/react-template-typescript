import React, { useEffect, useRef, useState } from "react";

/* =========================
   Data Type
========================= */
export interface WaferData {
  x: number;
  y: number;
  v: number;
  [key: string]: any; // ← 추가 데이터 전부 허용
}

interface Props {
  data: WaferData[];
  fontColor?: string;
  fontColorSelected?: string;
  onSelectionChange?: (selected: WaferData[]) => void;
}

type ActionType = "NONE" | "CLICK" | "DRAG_SELECT" | "PAN";

export default function WaferHeatmap({
  data,
  fontColor = "#111",
  fontColorSelected = "#fff",
  onSelectionChange,
}: Props) {
  const wrapperRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);

  /* =========================
     Meta
  ========================= */
  const metaRef = useRef({
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0,
    w: 0,
    h: 0,
  });

  /* =========================
     View
  ========================= */
  const scaleRef = useRef(1);
  const offsetRef = useRef({ x: 0, y: 0 });

  /* =========================
     Selection
  ========================= */
  const selectedRef = useRef<Set<string>>(new Set());

  /* =========================
     Drag / Action FSM
  ========================= */
  const dragRef = useRef({
    dragging: false,
    startX: 0,
    startY: 0,
    endX: 0,
    endY: 0,
  });

  const actionRef = useRef<{ type: ActionType; moved: boolean }>({
    type: "NONE",
    moved: false,
  });

  /* =========================
     Tooltip
  ========================= */
  const [tooltip, setTooltip] = useState<{
    data: WaferData;
    px: number;
    py: number;
  } | null>(null);

  /* =========================
     Meta 계산
  ========================= */
  useEffect(() => {
    if (!data.length) return;
    const xs = data.map(d => d.x);
    const ys = data.map(d => d.y);
    metaRef.current = {
      minX: Math.min(...xs),
      maxX: Math.max(...xs),
      minY: Math.min(...ys),
      maxY: Math.max(...ys),
      w: Math.max(...xs) - Math.min(...xs) + 1,
      h: Math.max(...ys) - Math.min(...ys) + 1,
    };
  }, [data]);

  /* =========================
     Resize
  ========================= */
  useEffect(() => {
    const wrapper = wrapperRef.current;
    const canvas = canvasRef.current;
    if (!wrapper || !canvas) return;

    const ro = new ResizeObserver(() => {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = wrapper.clientWidth * dpr;
      canvas.height = wrapper.clientHeight * dpr;
      canvas.style.width = `${wrapper.clientWidth}px`;
      canvas.style.height = `${wrapper.clientHeight}px`;
      draw();
    });

    ro.observe(wrapper);
    return () => ro.disconnect();
  }, [data]);

  /* =========================
     Helpers
  ========================= */
  const getCellSize = () => {
    const canvas = canvasRef.current!;
    const { w, h } = metaRef.current;
    const size = Math.min(canvas.clientWidth, canvas.clientHeight);
    return Math.max(8, Math.floor(size / Math.max(w, h)));
  };

  const emitSelection = () => {
    if (!onSelectionChange) return;
    onSelectionChange(
      data.filter(d => selectedRef.current.has(`${d.x},${d.y}`))
    );
  };

  /* =========================
     Draw
  ========================= */
  const draw = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d")!;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.setTransform(
      scaleRef.current,
      0,
      0,
      scaleRef.current,
      offsetRef.current.x,
      offsetRef.current.y
    );

    const { minX, maxY, w, h } = metaRef.current;
    const cell = getCellSize();
    const totalW = w * cell;
    const totalH = h * cell;

    const cx = (canvas.width / scaleRef.current - totalW) / 2;
    const cy = (canvas.height / scaleRef.current - totalH) / 2;

    for (const d of data) {
      const gx = d.x - minX;
      const gy = maxY - d.y;
      const px = cx + gx * cell;
      const py = cy + gy * cell;
      const key = `${d.x},${d.y}`;

      ctx.fillStyle = selectedRef.current.has(key)
        ? "rgba(255,80,80,0.85)"
        : `hsl(${240 - d.v * 2},75%,55%)`;
      ctx.fillRect(px, py, cell, cell);

      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.strokeRect(px + 0.5, py + 0.5, cell - 1, cell - 1);

      if (!Number.isNaN(d.v)) {
        ctx.fillStyle = selectedRef.current.has(key)
          ? fontColorSelected
          : fontColor;
        ctx.font = `${Math.floor(cell * 0.45)}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(String(d.v), px + cell / 2, py + cell / 2);
      }
    }

    // drag overlay
    if (dragRef.current.dragging && actionRef.current.type === "DRAG_SELECT") {
      const x = Math.min(dragRef.current.startX, dragRef.current.endX);
      const y = Math.min(dragRef.current.startY, dragRef.current.endY);
      const w = Math.abs(dragRef.current.endX - dragRef.current.startX);
      const h = Math.abs(dragRef.current.endY - dragRef.current.startY);

      ctx.fillStyle = "rgba(0,120,255,0.25)";
      ctx.strokeStyle = "rgba(0,120,255,0.9)";
      ctx.fillRect(
        x / scaleRef.current - offsetRef.current.x / scaleRef.current,
        y / scaleRef.current - offsetRef.current.y / scaleRef.current,
        w / scaleRef.current,
        h / scaleRef.current
      );
      ctx.strokeRect(
        x / scaleRef.current - offsetRef.current.x / scaleRef.current,
        y / scaleRef.current - offsetRef.current.y / scaleRef.current,
        w / scaleRef.current,
        h / scaleRef.current
      );
    }

    ctx.restore();
  };

  /* =========================
     Mouse Events
  ========================= */
  const handleDown = (e: React.MouseEvent) => {
    const rect = canvasRef.current!.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    dragRef.current = { dragging: true, startX: x, startY: y, endX: x, endY: y };
    actionRef.current = {
      type: e.shiftKey && scaleRef.current !== 1 ? "PAN" : "CLICK",
      moved: false,
    };
  };

  const handleMove = (e: React.MouseEvent) => {
    const canvas = canvasRef.current!;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // tooltip 계산
    const { minX, maxY } = metaRef.current;
    const cell = getCellSize();
    const cx = (canvas.clientWidth - metaRef.current.w * cell) / 2;
    const cy = (canvas.clientHeight - metaRef.current.h * cell) / 2;

    const lx = (x - offsetRef.current.x) / scaleRef.current - cx;
    const ly = (y - offsetRef.current.y) / scaleRef.current - cy;
    const gx = Math.floor(lx / cell);
    const gy = Math.floor(ly / cell);

    const tx = minX + gx;
    const ty = maxY - gy;
    const found = data.find(d => d.x === tx && d.y === ty);
    setTooltip(found ? { data: found, px: x, py: y } : null);

    if (!dragRef.current.dragging) return;

    const dx = Math.abs(x - dragRef.current.startX);
    const dy = Math.abs(y - dragRef.current.startY);
    if (dx > 3 || dy > 3) actionRef.current.moved = true;

    // PAN
    if (actionRef.current.type === "PAN") {
      offsetRef.current.x += x - dragRef.current.startX;
      offsetRef.current.y += y - dragRef.current.startY;
      dragRef.current.startX = x;
      dragRef.current.startY = y;
      draw();
      return;
    }

    // DRAG SELECT
    if (actionRef.current.moved) {
      actionRef.current.type = "DRAG_SELECT";
      dragRef.current.endX = x;
      dragRef.current.endY = y;

      const x0 = Math.min(dragRef.current.startX, dragRef.current.endX);
      const x1 = Math.max(dragRef.current.startX, dragRef.current.endX);
      const y0 = Math.min(dragRef.current.startY, dragRef.current.endY);
      const y1 = Math.max(dragRef.current.startY, dragRef.current.endY);

      for (const d of data) {
        const px = cx + (d.x - minX) * cell;
        const py = cy + (maxY - d.y) * cell;
        const sx = px * scaleRef.current + offsetRef.current.x;
        const sy = py * scaleRef.current + offsetRef.current.y;

        if (
          sx + cell * scaleRef.current >= x0 &&
          sx <= x1 &&
          sy + cell * scaleRef.current >= y0 &&
          sy <= y1
        ) {
          selectedRef.current.add(`${d.x},${d.y}`);
        }
      }
      draw();
    }
  };

  const handleUp = () => {
    dragRef.current.dragging = false;

    if (actionRef.current.type === "PAN") {
      actionRef.current.type = "NONE";
      draw();
      return;
    }

    if (actionRef.current.type === "DRAG_SELECT") {
      emitSelection();
      actionRef.current.type = "NONE";
      draw();
      return;
    }

    if (actionRef.current.type === "CLICK" && !actionRef.current.moved) {
      const { startX, startY } = dragRef.current;
      const canvas = canvasRef.current!;
      const { minX, maxY } = metaRef.current;
      const cell = getCellSize();
      const cx = (canvas.clientWidth - metaRef.current.w * cell) / 2;
      const cy = (canvas.clientHeight - metaRef.current.h * cell) / 2;

      const lx = (startX - offsetRef.current.x) / scaleRef.current - cx;
      const ly = (startY - offsetRef.current.y) / scaleRef.current - cy;
      const gx = Math.floor(lx / cell);
      const gy = Math.floor(ly / cell);

      const x = minX + gx;
      const y = maxY - gy;
      const key = `${x},${y}`;

      if (data.find(d => d.x === x && d.y === y)) {
        selectedRef.current.has(key)
          ? selectedRef.current.delete(key)
          : selectedRef.current.add(key);
        emitSelection();
      }
    }

    actionRef.current.type = "NONE";
    draw();
  };

  const handleWheel = (e: React.WheelEvent) => {
    if (!e.shiftKey) return;
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
    scaleRef.current = Math.min(10, Math.max(1, scaleRef.current * factor));
    draw();
  };

  /* =========================
     Render
  ========================= */
  return (
    <div
      ref={wrapperRef}
      style={{ width: "100%", height: "100%", position: "relative" }}
      onWheel={handleWheel}
    >
      <canvas
        ref={canvasRef}
        onMouseDown={handleDown}
        onMouseMove={handleMove}
        onMouseUp={handleUp}
        onMouseLeave={() => setTooltip(null)}
      />

      {tooltip && (
        <div
          style={{
            position: "absolute",
            left: tooltip.px + 10,
            top: tooltip.py + 10,
            background: "#000",
            color: "#fff",
            padding: "6px 8px",
            fontSize: 12,
            borderRadius: 4,
            pointerEvents: "none",
            maxWidth: 240,
            lineHeight: 1.4,
          }}
        >
          {Object.entries(tooltip.data).map(([k, v]) => (
            <div key={k}>
              <b>{k}</b>: {String(v)}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
