import { useEffect, useRef, useState } from "react";
import Plot from "react-plotly.js";
import Plotly from "plotly.js-dist-min";
import type { Layout, Config, Shape } from "plotly.js";

/* ================= 타입 ================= */
type PlotlyGraphDiv = HTMLDivElement & {
  layout: {
    xaxis: { range?: [number, number]; autorange?: boolean };
    yaxis: { range?: [number, number]; autorange?: boolean };
    shapes?: Shape[];
  };
};

type CellKey = `${number}-${number}`;

/* ================= 컴포넌트 ================= */
const WaferHeatmap: React.FC = () => {
  const wrapperRef = useRef<HTMLDivElement | null>(null);
  const plotRef = useRef<PlotlyGraphDiv | null>(null);

  /* ---------- 상태 ---------- */
  const isPanningRef = useRef(false);
  const isSelectingRef = useRef(false);

  const panStartRef = useRef({ x: 0, y: 0 });
  const selectStartRef = useRef({ x: 0, y: 0 });

  /* ================= 데이터 ================= */
  const R = 100;

  const x = Array.from({ length: 200 }, (_, i) => i - 100);
  const y = Array.from({ length: 200 }, (_, i) => i - 100);

  const originalZ = useRef<number[][]>(
    y.map((yy) =>
      x.map((xx) =>
        xx * xx + yy * yy <= R * R ? Math.random() * 10 : NaN
      )
    )
  );

  /* ---------- 선택 상태 ---------- */
  const selectedRef = useRef<Set<CellKey>>(new Set());

  const [selectedZ, setSelectedZ] = useState<number[][]>(
    y.map(() => x.map(() => NaN))
  );

  /* ================= layout / config ================= */
  const layout: Partial<Layout> = {
    dragmode: false,
    margin: { t: 20, r: 20, b: 20, l: 20 },
    xaxis: {
      range: [-100, 100],
      autorange: false,
      scaleanchor: "y",
      scaleratio: 1,
      zeroline: false,
    },
    yaxis: {
      range: [-100, 100],
      autorange: false,
      scaleanchor: "x",
      scaleratio: 1,
      zeroline: false,
    },
    shapes: [],
  };

  const config: Partial<Config> = {
    scrollZoom: false,
    doubleClick: false,
    displayModeBar: true,
  };

  /* ================= 좌표 변환 ================= */
  const pixelToData = (e: MouseEvent, plot: PlotlyGraphDiv) => {
    const rect = plot.getBoundingClientRect();
    const [x0, x1] = plot.layout.xaxis.range!;
    const [y0, y1] = plot.layout.yaxis.range!;

    return {
      x: x0 + ((e.clientX - rect.left) / rect.width) * (x1 - x0),
      y: y1 - ((e.clientY - rect.top) / rect.height) * (y1 - y0),
    };
  };

  /* ================= 선택 적용 ================= */
  const applySelection = (
    x0: number,
    y0: number,
    x1: number,
    y1: number,
    append: boolean
  ) => {
    const minX = Math.min(x0, x1);
    const maxX = Math.max(x0, x1);
    const minY = Math.min(y0, y1);
    const maxY = Math.max(y0, y1);

    const nextSelected = append
      ? new Set(selectedRef.current)
      : new Set<CellKey>();

    const selectedValues: number[] = [];

    y.forEach((yy, iy) => {
      if (yy < minY || yy > maxY) return;

      x.forEach((xx, ix) => {
        if (xx < minX || xx > maxX) return;

        const val = originalZ.current[iy][ix];
        if (Number.isNaN(val)) return;

        const key: CellKey = `${ix}-${iy}`;
        nextSelected.add(key);
        selectedValues.push(val);
      });
    });

    selectedRef.current = nextSelected;

    const newSelectedZ = y.map((_, iy) =>
      x.map((_, ix) =>
        selectedRef.current.has(`${ix}-${iy}`) ? 1 : NaN
      )
    );

    setSelectedZ(newSelectedZ);
    console.log("선택된 데이터:", selectedValues);
  };

  /* ================= 마우스 이벤트 ================= */
  useEffect(() => {
    const wrapper = wrapperRef.current;
    if (!wrapper) return;

    /* ---------- Shift + Wheel (Zoom) ---------- */
    const onWheel = (e: WheelEvent) => {
      if (!e.shiftKey) return;
      e.preventDefault();

      const plot = plotRef.current;
      if (!plot) return;

      const rect = plot.getBoundingClientRect();
      const [x0, x1] = plot.layout.xaxis.range!;
      const [y0, y1] = plot.layout.yaxis.range!;

      const zoom = e.deltaY > 0 ? 1.15 : 0.85;
      const cx =
        x0 + ((e.clientX - rect.left) / rect.width) * (x1 - x0);
      const cy =
        y1 - ((e.clientY - rect.top) / rect.height) * (y1 - y0);

      Plotly.relayout(plot, {
        "xaxis.range": [
          cx - (cx - x0) * zoom,
          cx + (x1 - cx) * zoom,
        ],
        "yaxis.range": [
          cy - (cy - y0) * zoom,
          cy + (y1 - cy) * zoom,
        ],
        "xaxis.autorange": false,
        "yaxis.autorange": false,
      });
    };

    /* ---------- Mouse Down ---------- */
    const onMouseDown = (e: MouseEvent) => {
      const plot = plotRef.current;
      if (!plot) return;

      if (e.shiftKey) {
        isPanningRef.current = true;
        panStartRef.current = { x: e.clientX, y: e.clientY };
        return;
      }

      isSelectingRef.current = true;
      selectStartRef.current = pixelToData(e, plot);

      Plotly.relayout(plot, {
        shapes: [
          {
            type: "rect",
            xref: "x",
            yref: "y",
            x0: selectStartRef.current.x,
            y0: selectStartRef.current.y,
            x1: selectStartRef.current.x,
            y1: selectStartRef.current.y,
            fillcolor: "rgba(0,120,255,0.2)",
            line: { width: 1, color: "#0078ff" },
          },
        ],
        "xaxis.autorange": false,
        "yaxis.autorange": false,
      });
    };

    /* ---------- Mouse Move ---------- */
    const onMouseMove = (e: MouseEvent) => {
      const plot = plotRef.current;
      if (!plot) return;

      if (isPanningRef.current) {
        const dx = e.clientX - panStartRef.current.x;
        const dy = e.clientY - panStartRef.current.y;
        panStartRef.current = { x: e.clientX, y: e.clientY };

        const [x0, x1] = plot.layout.xaxis.range!;
        const [y0, y1] = plot.layout.yaxis.range!;

        Plotly.relayout(plot, {
          "xaxis.range": [
            x0 - (dx / plot.clientWidth) * (x1 - x0),
            x1 - (dx / plot.clientWidth) * (x1 - x0),
          ],
          "yaxis.range": [
            y0 + (dy / plot.clientHeight) * (y1 - y0),
            y1 + (dy / plot.clientHeight) * (y1 - y0),
          ],
        });
        return;
      }

      if (isSelectingRef.current) {
        const current = pixelToData(e, plot);
        const shape = plot.layout.shapes?.[0];
        if (!shape) return;

        Plotly.relayout(plot, {
          shapes: [{ ...shape, x1: current.x, y1: current.y }],
          "xaxis.autorange": false,
          "yaxis.autorange": false,
        });
      }
    };

    /* ---------- Mouse Up ---------- */
    const onMouseUp = (e: MouseEvent) => {
      const plot = plotRef.current;
      if (!plot) return;

      if (isPanningRef.current) {
        isPanningRef.current = false;
        return;
      }

      if (isSelectingRef.current) {
        const end = pixelToData(e, plot);

        applySelection(
          selectStartRef.current.x,
          selectStartRef.current.y,
          end.x,
          end.y,
          e.ctrlKey
        );

        Plotly.relayout(plot, {
          shapes: [],
          "xaxis.autorange": false,
          "yaxis.autorange": false,
        });

        isSelectingRef.current = false;
      }
    };

    wrapper.addEventListener("wheel", onWheel, { passive: false });
    wrapper.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);

    return () => {
      wrapper.removeEventListener("wheel", onWheel);
      wrapper.removeEventListener("mousedown", onMouseDown);
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", onMouseUp);
    };
  }, []);

  /* ================= 렌더 ================= */
  return (
    <div ref={wrapperRef} style={{ width: "100%", height: "500px" }}>
      <Plot
        data={[
          {
            type: "heatmap",
            x,
            y,
            z: originalZ.current,
            colorscale: "Viridis",
            hoverongaps: false,
          },
          {
            type: "heatmap",
            x,
            y,
            z: selectedZ,
            colorscale: [[0, "rgba(0,0,0,0)"], [1, "#ff0000"]],
            showscale: false,
            hoverinfo: "skip",
          },
        ]}
        layout={layout}
        config={config}
        style={{ width: "100%", height: "100%" }}
        onInitialized={(_, gd) => {
          plotRef.current = gd as PlotlyGraphDiv;
        }}
        onUpdate={(_, gd) => {
          plotRef.current = gd as PlotlyGraphDiv;
        }}
      />
    </div>
  );
};

export default WaferHeatmap;
